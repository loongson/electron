From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Mingtao Zhou <zhoumingtao@loongson.cn>
Date: Mon, 18 Dec 2023 07:21:41 +0000
Subject: breakpad add support for LoongArch64

support ABI2.0

diff --git a/Makefile.am b/Makefile.am
index 1d45f8e561009cdfd307981e27049875775d84cb..9633d0481d1d3d3dca8dd489e036db31a0b19ff4 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -214,6 +214,7 @@ check_PROGRAMS += \
 	src/processor/stackwalker_arm_unittest \
 	src/processor/stackwalker_arm64_unittest \
 	src/processor/stackwalker_address_list_unittest \
+	src/processor/stackwalker_loongarch64_unittest \
 	src/processor/stackwalker_mips_unittest \
 	src/processor/stackwalker_mips64_unittest \
 	src/processor/stackwalker_riscv_unittest \
@@ -438,6 +439,8 @@ src_libbreakpad_a_SOURCES = \
 	src/processor/stackwalker_sparc.h \
 	src/processor/stackwalker_x86.cc \
 	src/processor/stackwalker_x86.h \
+	src/processor/stackwalker_loongarch64.cc \
+	src/processor/stackwalker_loongarch64.h \
 	src/processor/static_address_map-inl.h \
 	src/processor/static_address_map.h \
 	src/processor/static_contained_range_map-inl.h \
@@ -955,6 +958,7 @@ src_processor_exploitability_unittest_LDADD = \
 	src/processor/stackwalker_riscv64.o \
 	src/processor/stackwalker_sparc.o \
 	src/processor/stackwalker_x86.o \
+	src/processor/stackwalker_loongarch64.o \
 	src/processor/symbolic_constants_win.o \
 	src/processor/tokenize.o \
 	src/third_party/libdisasm/libdisasm.a \
@@ -1069,6 +1073,7 @@ src_processor_microdump_processor_unittest_LDADD = \
 	src/processor/stackwalker_riscv64.o \
 	src/processor/stackwalker_sparc.o \
 	src/processor/stackwalker_x86.o \
+	src/processor/stackwalker_loongarch64.o \
 	src/processor/tokenize.o \
 	$(TEST_LIBS) \
 	$(PTHREAD_CFLAGS) $(PTHREAD_LIBS)
@@ -1116,6 +1121,7 @@ src_processor_minidump_processor_unittest_LDADD = \
 	src/processor/stackwalker_riscv64.o \
 	src/processor/stackwalker_sparc.o \
 	src/processor/stackwalker_x86.o \
+	src/processor/stackwalker_loongarch64.o \
 	src/processor/symbolic_constants_win.o \
 	src/processor/tokenize.o \
 	src/third_party/libdisasm/libdisasm.a \
@@ -1266,6 +1272,7 @@ src_processor_stackwalker_selftest_LDADD = \
 	src/processor/stackwalker_riscv.o \
 	src/processor/stackwalker_riscv64.o \
 	src/processor/stackwalker_sparc.o \
+    src/processor/stackwalker_loongarch64.o \
 	src/processor/stackwalker_x86.o \
 	src/processor/tokenize.o \
 	$(PTHREAD_CFLAGS) $(PTHREAD_LIBS)
@@ -1366,6 +1373,16 @@ src_processor_stackwalker_x86_unittest_LDADD = \
 src_processor_stackwalker_x86_unittest_CPPFLAGS = \
 	$(AM_CPPFLAGS) $(TEST_CFLAGS)
 
+src_processor_stackwalker_loongarch64_unittest_SOURCES = \
+	src/common/test_assembler.cc \
+	src/processor/stackwalker_loongarch64_unittest.cc
+src_processor_stackwalker_loongarch64_unittest_LDADD = \
+	src/libbreakpad.a \
+	$(TEST_LIBS) \
+	$(PTHREAD_CFLAGS) $(PTHREAD_LIBS)
+src_processor_stackwalker_loongarch64_unittest_CPPFLAGS = \
+	$(AM_CPPFLAGS) $(TEST_CFLAGS)
+
 src_processor_synth_minidump_unittest_SOURCES = \
 	src/common/test_assembler.cc \
 	src/common/test_assembler.h \
@@ -1458,6 +1475,7 @@ src_processor_microdump_stackwalk_LDADD = \
 	src/processor/stackwalker_riscv.o \
 	src/processor/stackwalker_riscv64.o \
 	src/processor/stackwalker_sparc.o \
+    src/processor/stackwalker_loongarch64.o \
 	src/processor/stackwalker_x86.o \
 	src/processor/tokenize.o \
 	src/third_party/libdisasm/libdisasm.a
@@ -1506,6 +1524,7 @@ src_processor_minidump_stackwalk_LDADD = \
 	src/processor/stackwalker_riscv64.o \
 	src/processor/stackwalker_sparc.o \
 	src/processor/stackwalker_x86.o \
+	src/processor/stackwalker_loongarch64.o \
 	src/processor/symbolic_constants_win.o \
 	src/processor/tokenize.o \
 	src/third_party/libdisasm/libdisasm.a
diff --git a/src/client/linux/dump_writer_common/raw_context_cpu.h b/src/client/linux/dump_writer_common/raw_context_cpu.h
index ea4b6f6a2957df86ea803ffb9cdd60067c776e33..b7e71d40ec127762f2c26b391dcb6b46d6550817 100644
--- a/src/client/linux/dump_writer_common/raw_context_cpu.h
+++ b/src/client/linux/dump_writer_common/raw_context_cpu.h
@@ -51,6 +51,8 @@ typedef MDRawContextRISCV64 RawContextCPU;
 # else
 #  error "Unexpected __riscv_xlen"
 # endif
+#elif defined(__loongarch__) && __loongarch_grlen == 64
+typedef MDRawContextLOONGARCH64 RawContextCPU;
 #else
 #error "This code has not been ported to your platform yet."
 #endif
diff --git a/src/client/linux/dump_writer_common/thread_info.cc b/src/client/linux/dump_writer_common/thread_info.cc
index fc82c0c62f3c119e8459b76c93bb4d802512f570..503108e2a0660f47d593d5b48b74a93e0fba2cc0 100644
--- a/src/client/linux/dump_writer_common/thread_info.cc
+++ b/src/client/linux/dump_writer_common/thread_info.cc
@@ -340,7 +340,27 @@ void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
 #  error "Unexpected __riscv_flen"
 # endif
 }
-#endif  // __riscv
+
+#elif defined(__loongarch__) && __loongarch_grlen == 64
+
+uintptr_t ThreadInfo::GetInstructionPointer() const {
+  return regs.csr_era;
+}
+
+void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
+  out->context_flags = MD_CONTEXT_LOONGARCH64_FULL;
+
+  for (int i = 0; i < MD_CONTEXT_LOONGARCH64_GPR_COUNT; ++i)
+    out->iregs[i] = regs.regs[i];
+
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_LOONGARCH64_FPR_COUNT; ++i)
+    out->float_save.regs[i] = fpregs.fpr[i];
+  out->float_save.fcc = fpregs.fcc;
+  out->float_save.fcsr = fpregs.fcsr;
+
+  out->csr_era = regs.csr_era;
+}
+#endif
 
 void ThreadInfo::GetGeneralPurposeRegisters(void** gp_regs, size_t* size) {
   assert(gp_regs || size);
diff --git a/src/client/linux/dump_writer_common/thread_info.h b/src/client/linux/dump_writer_common/thread_info.h
index af786bcc9680fcb7bc6ec4b994eee7b518cde4c1..5b2154f44fb9421eea583139ff9b29afd2dff16c 100644
--- a/src/client/linux/dump_writer_common/thread_info.h
+++ b/src/client/linux/dump_writer_common/thread_info.h
@@ -70,6 +70,10 @@ struct ThreadInfo {
 #elif defined(__mips__) || defined(__riscv)
   // Use the structure defined in <sys/ucontext.h>.
   mcontext_t mcontext;
+#elif defined(__loongarch__)
+  // Use the structures defined in <sys/user.h>
+  struct user_regs_struct regs;
+  struct user_fp_struct fpregs;
 #endif
 
   // Returns the instruction pointer (platform-dependent impl.).
diff --git a/src/client/linux/dump_writer_common/ucontext_reader.cc b/src/client/linux/dump_writer_common/ucontext_reader.cc
index c6a8e9aade930ce96c65b703fbab407f3d0675fa..2b47e5c28518d975c249f15db9676f7eeaa8ac1b 100644
--- a/src/client/linux/dump_writer_common/ucontext_reader.cc
+++ b/src/client/linux/dump_writer_common/ucontext_reader.cc
@@ -326,6 +326,32 @@ void UContextReader::FillCPUContext(RawContextCPU* out, const ucontext_t* uc) {
   out->float_save.fpcsr = uc->uc_mcontext.__fpregs.__q.__fcsr;
 # endif
 }
+
+#elif defined(__loongarch__) && __loongarch_grlen == 64
+
+uintptr_t UContextReader::GetStackPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.__gregs[MD_CONTEXT_LOONGARCH64_REG_SP];
+}
+
+uintptr_t UContextReader::GetInstructionPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.__pc;
+}
+
+void UContextReader::FillCPUContext(RawContextCPU* out,
+                                    const ucontext_t* uc,
+                                    const fpstate_t* fpregs) {
+  out->context_flags = MD_CONTEXT_LOONGARCH64_FULL;
+
+  for (int i = 0; i < MD_CONTEXT_LOONGARCH64_GPR_COUNT; ++i)
+    out->iregs[i] = uc->uc_mcontext.__gregs[i];
+
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_LOONGARCH64_FPR_COUNT; ++i)
+    out->float_save.regs[i] = fpregs->regs[i];
+  out->float_save.fcc = fpregs->fcc;
+  out->float_save.fcsr = fpregs->fcsr;
+
+  out->csr_era = uc->uc_mcontext.__pc;
+}
 #endif
 
 }  // namespace google_breakpad
diff --git a/src/client/linux/dump_writer_common/ucontext_reader.h b/src/client/linux/dump_writer_common/ucontext_reader.h
index 60cbf90047bb9146b9ce473e9d8af065d5e569d4..fa757e73ac35741ba84032220238e96b9d6df0c9 100644
--- a/src/client/linux/dump_writer_common/ucontext_reader.h
+++ b/src/client/linux/dump_writer_common/ucontext_reader.h
@@ -54,6 +54,10 @@ struct UContextReader {
 #elif defined(__aarch64__)
   static void FillCPUContext(RawContextCPU* out, const ucontext_t* uc,
                              const struct fpsimd_context* fpregs);
+#elif defined(__loongarch__) && __loongarch_grlen == 64
+  static void FillCPUContext(RawContextCPU* out,
+                             const ucontext_t* uc,
+                             const fpstate_t* fpregs);
 #else
   static void FillCPUContext(RawContextCPU* out, const ucontext_t* uc);
 #endif
diff --git a/src/client/linux/handler/exception_handler.cc b/src/client/linux/handler/exception_handler.cc
index 9e23c1194e21b00943029892d4b08f01817992a4..015afb387bd5b57ab25d70c3674cf71ec77eb1f0 100644
--- a/src/client/linux/handler/exception_handler.cc
+++ b/src/client/linux/handler/exception_handler.cc
@@ -464,6 +464,17 @@ bool ExceptionHandler::HandleSignal(int /*sig*/, siginfo_t* info, void* uc) {
     memcpy(&g_crash_context_.float_state, fp_ptr,
            sizeof(g_crash_context_.float_state));
   }
+#elif defined(__loongarch__) && __loongarch_frlen == 64
+  ucontext_t* uc_ptr = (ucontext_t*)uc;
+  struct sctx_info* ctx_info_ptr =
+      (struct sctx_info*)&uc_ptr->uc_mcontext.__extcontext;
+  if (ctx_info_ptr->magic == FPU_CTX_MAGIC) {
+    struct fpu_context* fpu_ptr =
+        (struct fpu_context*)(&uc_ptr->uc_mcontext.__extcontext +
+                              sizeof(struct sctx_info));
+    memcpy(&g_crash_context_.float_state, fpu_ptr,
+           sizeof(g_crash_context_.float_state));
+  }
 #elif GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
   ucontext_t* uc_ptr = (ucontext_t*)uc;
   if (uc_ptr->uc_mcontext.fpregs) {
@@ -701,7 +712,8 @@ bool ExceptionHandler::WriteMinidump() {
   }
 #endif
 
-#if GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE && !defined(__aarch64__)
+#if GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE && !defined(__aarch64__) && \
+    !defined(__loongarch__)
   memcpy(&context.float_state, context.context.uc_mcontext.fpregs,
          sizeof(context.float_state));
 #endif
@@ -728,6 +740,9 @@ bool ExceptionHandler::WriteMinidump() {
 #elif defined(__riscv)
   context.siginfo.si_addr =
       reinterpret_cast<void*>(context.context.uc_mcontext.__gregs[REG_PC]);
+#elif defined(__loongarch__) && __loongarch_grlen == 64
+  context.siginfo.si_addr =
+      reinterpret_cast<void*>(context.context.uc_mcontext.__pc);
 #else
 # error "This code has not been ported to your platform yet."
 #endif
diff --git a/src/client/linux/handler/exception_handler_unittest.cc b/src/client/linux/handler/exception_handler_unittest.cc
index b2d8d46811d8b1bd314b92b5e6eea0a18fac3240..be27ba53b7fe43dba1fb5b26712b5d8836bd90f5 100644
--- a/src/client/linux/handler/exception_handler_unittest.cc
+++ b/src/client/linux/handler/exception_handler_unittest.cc
@@ -771,10 +771,10 @@ TEST(ExceptionHandlerTest, InstructionPointerMemoryMaxBound) {
 
   // These are defined here so the parent can use them to check the
   // data from the minidump afterwards.
-  // Use 4k here because the OS will hand out a single page even
+  // Use PAGESIZE here because the OS will hand out a single page even
   // if a smaller size is requested, and this test wants to
   // test the upper bound of the memory range.
-  const uint32_t kMemorySize = 4096;  // bytes
+  const uint32_t kMemorySize = sysconf(_SC_PAGESIZE);  // bytes
   const int kOffset = kMemorySize - sizeof(kIllegalInstruction);
 
   const pid_t child = fork();
diff --git a/src/client/linux/microdump_writer/microdump_writer.cc b/src/client/linux/microdump_writer/microdump_writer.cc
index 93dae35e5c10e72be5293a6ae4e0b87bfd24e2f6..05531883ba356e055c9d747f645414590bb3911a 100644
--- a/src/client/linux/microdump_writer/microdump_writer.cc
+++ b/src/client/linux/microdump_writer/microdump_writer.cc
@@ -348,6 +348,8 @@ class MicrodumpWriter {
 # else
 #  error "Unexpected __riscv_xlen"
 # endif
+#elif defined(__loongarch__) && __loongarch_grlen == 64
+    const char kArch[] = "loongarch64";
 #else
 # error "This code has not been ported to your platform yet"
 #endif
diff --git a/src/client/linux/microdump_writer/microdump_writer_unittest.cc b/src/client/linux/microdump_writer/microdump_writer_unittest.cc
index b1d570eb4de6767186b56177b1b8fd05b50db679..239f2ba353f41f89c9aaa5a1a8fba6a0e6a565c0 100644
--- a/src/client/linux/microdump_writer/microdump_writer_unittest.cc
+++ b/src/client/linux/microdump_writer/microdump_writer_unittest.cc
@@ -283,9 +283,15 @@ TEST(MicrodumpWriterTest, BasicWithMappings) {
   ASSERT_TRUE(ContainsMicrodump(buf));
 
 #ifdef __LP64__
-  ASSERT_NE(std::string::npos,
-            buf.find("M 0000000000001000 000000000000002A 0000000000001000 "
-                     "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  if (!(memory_size >> 13)) {
+    ASSERT_NE(std::string::npos,
+              buf.find("M 0000000000001000 000000000000002A 0000000000001000 "
+                       "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  } else if (!(memory_size >> 15)) {
+    ASSERT_NE(std::string::npos,
+              buf.find("M 0000000000004000 000000000000002A 0000000000004000 "
+                       "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  }
 #else
   ASSERT_NE(std::string::npos,
             buf.find("M 00001000 0000002A 00001000 "
diff --git a/src/client/linux/minidump_writer/linux_core_dumper.cc b/src/client/linux/minidump_writer/linux_core_dumper.cc
index 4bf9094e98259fefd951e12b0180fc14cad4c459..e1b98b2bc4c467272a897e7984d12216d7d6dcf4 100644
--- a/src/client/linux/minidump_writer/linux_core_dumper.cc
+++ b/src/client/linux/minidump_writer/linux_core_dumper.cc
@@ -41,7 +41,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <sys/procfs.h>
-#if defined(__mips__) && defined(__ANDROID__)
+#if (defined(__mips__) && defined(__ANDROID__)) || defined(__loongarch__)
 // To get register definitions.
 #include <asm/reg.h>
 #endif
@@ -118,6 +118,9 @@ bool LinuxCoreDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
 #elif defined(__riscv)
     stack_pointer = reinterpret_cast<uint8_t*>(
         info->mcontext.__gregs[MD_CONTEXT_RISCV_REG_SP]);
+#elif defined(__loongarch__) && __loongarch_grlen == 64
+  memcpy(&stack_pointer, &info->regs.regs[MD_CONTEXT_LOONGARCH64_REG_SP],
+         sizeof(info->regs.regs[MD_CONTEXT_LOONGARCH64_REG_SP]));
 #else
 # error "This code hasn't been ported to your platform yet."
 #endif
@@ -227,7 +230,12 @@ bool LinuxCoreDumper::EnumerateThreads() {
 #elif defined(__riscv)
         memcpy(&info.mcontext.__gregs, status->pr_reg,
                sizeof(info.mcontext.__gregs));
-#else  // __riscv
+#elif defined(__loongarch__) && __loongarch_grlen == 64
+        memcpy(info.regs.regs, &status->pr_reg[LOONGARCH_EF_R0],
+               sizeof(info.regs.regs));
+        memcpy(&info.regs.csr_era, &status->pr_reg[LOONGARCH_EF_CSR_ERA],
+               sizeof(info.regs.csr_era));
+#else  // __loongarch__
         memcpy(&info.regs, status->pr_reg, sizeof(info.regs));
 #endif
         if (first_thread) {
diff --git a/src/client/linux/minidump_writer/linux_dumper.h b/src/client/linux/minidump_writer/linux_dumper.h
index 2d5b2e52b6038ef3ecde4b6c24ae4a4295b77cae..e9a80d07ab58f86b9dec6f4a792c67aea44544bb 100644
--- a/src/client/linux/minidump_writer/linux_dumper.h
+++ b/src/client/linux/minidump_writer/linux_dumper.h
@@ -64,7 +64,8 @@ namespace google_breakpad {
 typedef Elf32_auxv_t elf_aux_entry;
 #elif defined(__x86_64) || defined(__aarch64__) || \
      (defined(__mips__) && _MIPS_SIM != _ABIO32) || \
-     (defined(__riscv) && __riscv_xlen == 64)
+     (defined(__riscv) && __riscv_xlen == 64) || \
+     (defined(__loongarch__) && __loongarch_grlen == 64)
 typedef Elf64_auxv_t elf_aux_entry;
 #endif
 
diff --git a/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc b/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
index 5a135fda0e9221045cdabfcee860685925c0d645..caaf3e0e5b324cef06a8d7695ba59fb73963a911 100644
--- a/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
+++ b/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
@@ -56,6 +56,8 @@
 #define TID_PTR_REGISTER "$1"
 #elif defined(__riscv)
 #define TID_PTR_REGISTER "x4"
+#elif defined(__loongarch__)
+#define TID_PTR_REGISTER "$r1"
 #else
 #error This test has not been ported to this platform.
 #endif
diff --git a/src/client/linux/minidump_writer/linux_ptrace_dumper.cc b/src/client/linux/minidump_writer/linux_ptrace_dumper.cc
index 0e58236b6e1fd6b627243192c1e7625d4d8dcef2..4a0cf4bd5325141d9f426a853874ee0ed407f698 100644
--- a/src/client/linux/minidump_writer/linux_ptrace_dumper.cc
+++ b/src/client/linux/minidump_writer/linux_ptrace_dumper.cc
@@ -56,6 +56,9 @@
 #if defined(__i386)
 #include <cpuid.h>
 #endif
+#if defined(__loongarch__)
+#include <asm/reg.h>
+#endif
 
 #include "client/linux/minidump_writer/directory_reader.h"
 #include "client/linux/minidump_writer/line_reader.h"
@@ -289,6 +292,12 @@ bool LinuxPtraceDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
              reinterpret_cast<void*>(DSP_CONTROL), &info->mcontext.dsp);
 #endif
 
+#if defined(__loongarch__)
+  sys_ptrace(PTRACE_PEEKUSER, tid,
+             reinterpret_cast<void*>(LOONGARCH_EF_CSR_ERA),
+             &info->regs.csr_era);
+#endif
+
   const uint8_t* stack_pointer;
 #if defined(__i386)
   my_memcpy(&stack_pointer, &info->regs.esp, sizeof(info->regs.esp));
@@ -304,6 +313,9 @@ bool LinuxPtraceDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
 #elif defined(__riscv)
   stack_pointer = reinterpret_cast<uint8_t*>(
       info->mcontext.__gregs[MD_CONTEXT_RISCV_REG_SP]);
+#elif defined(__loongarch__) && __loongarch_grlen == 64
+  my_memcpy(&stack_pointer, &info->regs.regs[MD_CONTEXT_LOONGARCH64_REG_SP],
+            sizeof(info->regs.regs[MD_CONTEXT_LOONGARCH64_REG_SP]));
 #else
 # error "This code hasn't been ported to your platform yet."
 #endif
diff --git a/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc b/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
index 16a9daf1d00a1e529a4ffec3587435679d4af979..e64f75f8074632cc58b4513b8d5753aec7d38cfa 100644
--- a/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
+++ b/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
@@ -470,6 +470,9 @@ TEST(LinuxPtraceDumperTest, VerifyStackReadWithMultipleThreads) {
 #elif defined(__riscv)
     pid_t* process_tid_location =
         reinterpret_cast<pid_t*>(one_thread.mcontext.__gregs[4]);
+#elif defined(__loongarch__)
+    pid_t* process_tid_location =
+        reinterpret_cast<pid_t*>(one_thread.regs.regs[1]);
 #else
 #error This test has not been ported to this platform.
 #endif
@@ -569,6 +572,8 @@ TEST_F(LinuxPtraceDumperTest, SanitizeStackCopy) {
   uintptr_t heap_addr = thread_info.mcontext.gregs[1];
 #elif defined(__riscv)
   uintptr_t heap_addr = thread_info.mcontext.__gregs[4];
+#elif defined(__loongarch__)
+  uintptr_t heap_addr = thread_info.regs.regs[1];
 #else
 #error This test has not been ported to this platform.
 #endif
diff --git a/src/client/linux/minidump_writer/minidump_writer.cc b/src/client/linux/minidump_writer/minidump_writer.cc
index a95dd25480ded85175ae79152d3567df08a90d06..a92302cb189c5deac800233dfe7df88c0993b776 100644
--- a/src/client/linux/minidump_writer/minidump_writer.cc
+++ b/src/client/linux/minidump_writer/minidump_writer.cc
@@ -953,7 +953,8 @@ class MinidumpWriter {
     dirent->location.rva = 0;
   }
 
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
+    (defined(__loongarch__) && __loongarch_grlen == 64)
   bool WriteCPUInformation(MDRawSystemInfo* sys_info) {
     char vendor_id[sizeof(sys_info->cpu.x86_cpu_info.vendor_id) + 1] = {0};
     static const char vendor_id_name[] = "vendor_id";
@@ -981,6 +982,8 @@ class MinidumpWriter {
 # else
 #  error "This mips ABI is currently not supported (n32)"
 #endif
+#elif defined(__loongarch__) && __loongarch_grlen == 64
+        MD_CPU_ARCHITECTURE_LOONGARCH64;
 #elif defined(__i386__)
         MD_CPU_ARCHITECTURE_X86;
 #else
diff --git a/src/client/linux/minidump_writer/minidump_writer.h b/src/client/linux/minidump_writer/minidump_writer.h
index 24e3c7bdc263ee0aac184d1407300bd1a598f617..1989f13fd7613e80e881696e7d4019bb8a23a2b4 100644
--- a/src/client/linux/minidump_writer/minidump_writer.h
+++ b/src/client/linux/minidump_writer/minidump_writer.h
@@ -47,6 +47,8 @@ class ExceptionHandler;
 
 #if defined(__aarch64__)
 typedef struct fpsimd_context fpstate_t;
+#elif defined(__loongarch__) && __loongarch_frlen == 64
+typedef struct fpu_context fpstate_t;
 #elif !defined(__ARM_EABI__) && !defined(__mips__)
 typedef std::remove_pointer<fpregset_t>::type fpstate_t;
 #endif
diff --git a/src/client/linux/minidump_writer/minidump_writer_unittest.cc b/src/client/linux/minidump_writer/minidump_writer_unittest.cc
index effedc5e174ae29fa32cb6b483bd24528ff9bb41..208fffb973a86dd2a3b1e3a1c22a19937adaaaeb 100644
--- a/src/client/linux/minidump_writer/minidump_writer_unittest.cc
+++ b/src/client/linux/minidump_writer/minidump_writer_unittest.cc
@@ -723,6 +723,9 @@ TEST(MinidumpWriterTest, InvalidStackPointer) {
 #elif defined(__riscv)
   context.context.uc_mcontext.__gregs[MD_CONTEXT_RISCV_REG_SP] =
       invalid_stack_pointer;
+#elif defined(__loongarch__) && __loongarch_grlen == 64
+  context.context.uc_mcontext.__gregs[MD_CONTEXT_LOONGARCH64_REG_SP] =
+      invalid_stack_pointer;
 #else
 # error "This code has not been ported to your platform yet."
 #endif
diff --git a/src/common/dwarf_cfi_to_module.cc b/src/common/dwarf_cfi_to_module.cc
index 7e04d3c557b85bb74e7e06952ae0d0f25f412fc7..da68d4569b5fbf4f5b7716105da40b8a2b5c2be0 100644
--- a/src/common/dwarf_cfi_to_module.cc
+++ b/src/common/dwarf_cfi_to_module.cc
@@ -170,6 +170,22 @@ vector<string> DwarfCFIToModule::RegisterNames::RISCV() {
   return MakeVector(names, sizeof(names) / sizeof(names[0]));
 }
 
+vector<string> DwarfCFIToModule::RegisterNames::LOONGARCH64() {
+  static const char* const kRegisterNames[] = {
+      "$zero", "$ra",  "$tp",   "$sp",   "$a0",   "$a1",   "$a2",   "$a3",
+      "$a4",   "$a5",  "$a6",   "$a7",   "$t0",   "$t1",   "$t2",   "$t3",
+      "$t4",   "$t5",  "$t6",   "$t7",   "$t8",   "$x",    "$fp",   "$s0",
+      "$s1",   "$s2",  "$s3",   "$s4",   "$s5",   "$s6",   "$s7",   "$s8",
+      "$fa0",  "$fa1", "$fa2",  "$fa3",  "$fa4",  "$fa5",  "$fa6",  "$fa7",
+      "$ft0",  "$ft1", "$ft2",  "$ft3",  "$ft4",  "$ft5",  "$ft6",  "$ft7",
+      "$ft8",  "$ft9", "$ft10", "$ft11", "$ft12", "$ft13", "$ft14", "$ft15",
+      "$fs0",  "$fs1", "$fs2",  "$fs3",  "$fs4",  "$fs5",  "$fs6",  "$fs7",
+  };
+
+  return MakeVector(kRegisterNames,
+                    sizeof(kRegisterNames) / sizeof(kRegisterNames[0]));
+}
+
 bool DwarfCFIToModule::Entry(size_t offset, uint64_t address, uint64_t length,
                              uint8_t version, const string& augmentation,
                              unsigned return_address) {
diff --git a/src/common/dwarf_cfi_to_module.h b/src/common/dwarf_cfi_to_module.h
index 19297db93f3e09d10605ee2421eee1a9aee2e382..96055314ad32d99f992ea96b9a2ac7e843da2ede 100644
--- a/src/common/dwarf_cfi_to_module.h
+++ b/src/common/dwarf_cfi_to_module.h
@@ -117,6 +117,9 @@ class DwarfCFIToModule: public CallFrameInfo::Handler {
     // RISC-V.
     static vector<string> RISCV();
 
+    // LOONGARCH64.
+    static vector<string> LOONGARCH64();
+
    private:
     // Given STRINGS, an array of C strings with SIZE elements, return an
     // equivalent vector<string>.
diff --git a/src/common/linux/breakpad_getcontext.S b/src/common/linux/breakpad_getcontext.S
index 286047bf5a92249fb6a100a372196fa5da543900..58297b4dc1f01d79ee2f180abe638bb51e39c754 100644
--- a/src/common/linux/breakpad_getcontext.S
+++ b/src/common/linux/breakpad_getcontext.S
@@ -620,6 +620,46 @@ breakpad_getcontext:
   .cfi_endproc
   .size breakpad_getcontext, . - breakpad_getcontext
 
+#elif defined(__loongarch__)
+
+#define  _NSIG                       64
+#define  __NR_rt_sigprocmask         135
+
+  .text
+  .global breakpad_getcontext
+  .hidden breakpad_getcontext
+  .type breakpad_getcontext, @function
+  .align 4
+breakpad_getcontext:
+  STORE_GP $ra, $a0, MCONTEXT_PC_OFFSET
+  STORE_GP $ra, $a0, (MCONTEXT_GREGS_OFFSET + MCONTEXT_GREG_SIZE * 1)
+  STORE_GP $tp, $a0, (MCONTEXT_GREGS_OFFSET + MCONTEXT_GREG_SIZE * 2)
+  STORE_GP $sp, $a0, (MCONTEXT_GREGS_OFFSET + MCONTEXT_GREG_SIZE * 3)
+  STORE_GP $x,  $a0, (MCONTEXT_GREGS_OFFSET + MCONTEXT_GREG_SIZE * 21)
+  STORE_GP $fp, $a0, (MCONTEXT_GREGS_OFFSET + MCONTEXT_GREG_SIZE * 22)
+  STORE_GP $s0, $a0, (MCONTEXT_GREGS_OFFSET + MCONTEXT_GREG_SIZE * 23)
+  STORE_GP $s1, $a0, (MCONTEXT_GREGS_OFFSET + MCONTEXT_GREG_SIZE * 24)
+  STORE_GP $s2, $a0, (MCONTEXT_GREGS_OFFSET + MCONTEXT_GREG_SIZE * 25)
+  STORE_GP $s3, $a0, (MCONTEXT_GREGS_OFFSET + MCONTEXT_GREG_SIZE * 26)
+  STORE_GP $s4, $a0, (MCONTEXT_GREGS_OFFSET + MCONTEXT_GREG_SIZE * 27)
+  STORE_GP $s5, $a0, (MCONTEXT_GREGS_OFFSET + MCONTEXT_GREG_SIZE * 28)
+  STORE_GP $s6, $a0, (MCONTEXT_GREGS_OFFSET + MCONTEXT_GREG_SIZE * 29)
+  STORE_GP $s7, $a0, (MCONTEXT_GREGS_OFFSET + MCONTEXT_GREG_SIZE * 30)
+  STORE_GP $s8, $a0, (MCONTEXT_GREGS_OFFSET + MCONTEXT_GREG_SIZE * 31)
+
+  /* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc.uc_sigmask, _NSIG8) */
+  li.d    $a0, 0  /* SIG_BLOCK */
+  li.d    $a1, 0  /* NULL */
+  addi.d  $a2, $a0, UCONTEXT_SIGMASK_OFFSET
+  li.d    $a3, (_NSIG / 8)
+  li.d    $a7, __NR_rt_sigprocmask
+  syscall 0
+
+  /* Return zero for success */
+  move $a0, $zero
+  jirl $zero, $ra, 0
+
+  .size breakpad_getcontext, . - breakpad_getcontext
 #else
 # error "This file has not been ported for your CPU!"
 #endif
diff --git a/src/common/linux/breakpad_getcontext_unittest.cc b/src/common/linux/breakpad_getcontext_unittest.cc
index 5b340eb74e22720b272ed91308a7a083e716b3d9..f08103e4ec9f151753c00b40e1423a7abba8bf6b 100644
--- a/src/common/linux/breakpad_getcontext_unittest.cc
+++ b/src/common/linux/breakpad_getcontext_unittest.cc
@@ -136,6 +136,13 @@ TEST(AndroidUContext, GRegsOffset) {
 
   ASSERT_EQ(static_cast<size_t>(MCONTEXT_FPC_CSR),
             offsetof(ucontext_t,uc_mcontext.__fpregs.__fcsr));
+#elif defined(__loongarch__) && __loongarch_grlen == 64
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
+            offsetof(ucontext_t, uc.uc_mcontext.__regs[0]));
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_PC_OFFSET),
+            offsetof(ucontext_t, uc.uc_mcontext.__pc));
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_EXTENSION_OFFSET),
+            offsetof(ucontext_t, uc.uc_mcontext.__extcontext));
 #elif defined(__x86_64__)
 
   COMPILE_ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
@@ -165,7 +172,6 @@ TEST(AndroidUContext, GRegsOffset) {
   // sigcontext is an analog to mcontext_t. The layout should be the same.
   COMPILE_ASSERT_EQ(offsetof(mcontext_t,fpregs),
                     offsetof(sigcontext,fpstate), sigcontext_fpstate);
-
 #if defined(__ANDROID__)
   // Check that _fpstate from asm/sigcontext.h is essentially the same
   // as _libc_fpstate.
diff --git a/src/common/linux/dump_symbols.cc b/src/common/linux/dump_symbols.cc
index 8179663bb38cb2ad85b008da71763258ac260ac8..814bda53c93bfd31b4fa400f64171574973d47a6 100644
--- a/src/common/linux/dump_symbols.cc
+++ b/src/common/linux/dump_symbols.cc
@@ -108,6 +108,10 @@ using google_breakpad::wasteful_vector;
 #define EM_AARCH64      183
 #endif
 
+#ifndef EM_LOONGARCH
+#define EM_LOONGARCH    258
+#endif
+
 //
 // FDWrapper
 //
@@ -452,6 +456,9 @@ bool DwarfCFIRegisterNames(const typename ElfClass::Ehdr* elf_header,
     case EM_RISCV:
       *register_names = DwarfCFIToModule::RegisterNames::RISCV();
       return true;
+    case EM_LOONGARCH:
+      *register_names = DwarfCFIToModule::RegisterNames::LOONGARCH64();
+      return true;
     default:
       return false;
   }
@@ -1026,6 +1033,7 @@ const char* ElfArchitecture(const typename ElfClass::Ehdr* elf_header) {
     case EM_SPARCV9:    return "sparcv9";
     case EM_X86_64:     return "x86_64";
     case EM_RISCV:      return "riscv";
+    case EM_LOONGARCH:  return "loongarch64";
     default: return NULL;
   }
 }
diff --git a/src/common/linux/memory_mapped_file.cc b/src/common/linux/memory_mapped_file.cc
index a7b96eb591f741546005a53f9d8125df421ef881..e23bc81beefc0eddc6a93629c837a78556e227c5 100644
--- a/src/common/linux/memory_mapped_file.cc
+++ b/src/common/linux/memory_mapped_file.cc
@@ -72,7 +72,8 @@ bool MemoryMappedFile::Map(const char* path, size_t offset) {
 
 #if defined(__x86_64__) || defined(__aarch64__) || \
    (defined(__mips__) && _MIPS_SIM == _ABI64) || \
-   (defined(__riscv) && __riscv_xlen == 64)
+   (defined(__riscv) && __riscv_xlen == 64) ||  \
+    (defined(__loongarch__) && __loongarch_grlen == 64)
 
   struct kernel_stat st;
   if (sys_fstat(fd, &st) == -1 || st.st_size < 0) {
diff --git a/src/common/linux/memory_mapped_file_unittest.cc b/src/common/linux/memory_mapped_file_unittest.cc
index b7a61a70e81bb06b5d78936c6efa2cf5451d96b2..19a6530587eafe665ccbc54097e5c7d53af7261e 100644
--- a/src/common/linux/memory_mapped_file_unittest.cc
+++ b/src/common/linux/memory_mapped_file_unittest.cc
@@ -179,9 +179,10 @@ TEST_F(MemoryMappedFileTest, RemapAfterMap) {
 TEST_F(MemoryMappedFileTest, MapWithOffset) {
   // Put more data in the test file this time. Offsets can only be
   // done on page boundaries, so we need a two page file to test this.
-  const int page_size = 4096;
-  char data1[2 * page_size];
-  size_t data1_size = sizeof(data1);
+  const int page_size = sysconf(_SC_PAGESIZE);
+  char* data1 = static_cast<char*>(malloc(2 * page_size));
+  ASSERT_TRUE(data1 != NULL);
+  size_t data1_size = page_size * 2;
   for (size_t i = 0; i < data1_size; ++i) {
     data1[i] = i & 0x7f;
   }
@@ -208,4 +209,5 @@ TEST_F(MemoryMappedFileTest, MapWithOffset) {
         0,
         memcmp(data1 + page_size, mapped_file.data(), data1_size - page_size));
   }
+  free(data1);
 }
diff --git a/src/common/linux/ucontext_constants.h b/src/common/linux/ucontext_constants.h
index 3dcdecb08bb3eafa6cf55aecfcf19ed4f48af833..1f19810e290ccf1c5657ef2499481c782065c70c 100644
--- a/src/common/linux/ucontext_constants.h
+++ b/src/common/linux/ucontext_constants.h
@@ -244,6 +244,15 @@
 
 #define MCONTEXT_FPC_CSR      MCONTEXT_FPREGS_OFFSET + 32*MCONTEXT_FPREGS_SIZE
 
+#elif defined(__loongarch__) && __loongarch_grlen == 64
+
+#define MCONTEXT_GREG_SIZE 8
+#define MCONTEXT_FPREG_SIZE 8
+#define UCONTEXT_SIGMASK_OFFSET 40
+#define MCONTEXT_PC_OFFSET 176
+#define MCONTEXT_GREGS_OFFSET 184
+#define STORE_GP st.d
+
 #else
 # error "This header has not been ported for your CPU"
 #endif
diff --git a/src/common/memory_allocator_unittest.cc b/src/common/memory_allocator_unittest.cc
index 8ef68913be19f41ae766d444ed20158bc195235c..845c8a9bcdf9e1e2c4dc0c2e5491ed707cd39046 100644
--- a/src/common/memory_allocator_unittest.cc
+++ b/src/common/memory_allocator_unittest.cc
@@ -59,7 +59,8 @@ TEST(PageAllocatorTest, LargeObject) {
   PageAllocator allocator;
 
   EXPECT_EQ(0U, allocator.pages_allocated());
-  uint8_t* p = reinterpret_cast<uint8_t*>(allocator.Alloc(10000));
+  uint8_t* p =
+      reinterpret_cast<uint8_t*>(allocator.Alloc(2 * getpagesize() + 1));
   ASSERT_FALSE(p == NULL);
   EXPECT_EQ(3U, allocator.pages_allocated());
   for (unsigned i = 1; i < 10; ++i) {
diff --git a/src/google_breakpad/common/minidump_cpu_loongarch64.h b/src/google_breakpad/common/minidump_cpu_loongarch64.h
new file mode 100644
index 0000000000000000000000000000000000000000..a719599ca7de0d9c4ad6ebe276595b3262f24108
--- /dev/null
+++ b/src/google_breakpad/common/minidump_cpu_loongarch64.h
@@ -0,0 +1,148 @@
+/* Copyright 2013 Google LLC
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google LLC nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
+
+/* minidump_format.h: A cross-platform reimplementation of minidump-related
+ * portions of DbgHelp.h from the Windows Platform SDK.
+ *
+ * (This is C99 source, please don't corrupt it with C++.)
+ *
+ * This file contains the necessary definitions to read minidump files
+ * produced on LOONGARCH.  These files may be read on any platform provided
+ * that the alignments of these structures on the processing system are
+ * identical to the alignments of these structures on the producing system.
+ * For this reason, precise-sized types are used.  The structures defined
+ * by this file have been laid out to minimize alignment problems by
+ * ensuring that all members are aligned on their natural boundaries.
+ * In some cases, tail-padding may be significant when different ABIs specify
+ * different tail-padding behaviors.  To avoid problems when reading or
+ * writing affected structures, MD_*_SIZE macros are provided where needed,
+ * containing the useful size of the structures without padding.
+ *
+ * Structures that are defined by Microsoft to contain a zero-length array
+ * are instead defined here to contain an array with one element, as
+ * zero-length arrays are forbidden by standard C and C++.  In these cases,
+ * *_minsize constants are provided to be used in place of sizeof.  For a
+ * cleaner interface to these sizes when using C++, see minidump_size.h.
+ *
+ * These structures are also sufficient to populate minidump files.
+ *
+ * Because precise data type sizes are crucial for this implementation to
+ * function properly and portably, a set of primitive types with known sizes
+ * are used as the basis of each structure defined by this file.
+ */
+
+/*
+ * Loongarch64 support
+ */
+
+#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_LOONGARCH64_H__
+#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_LOONGARCH64_H__
+
+#define MD_CONTEXT_LOONGARCH64_GPR_COUNT 32
+#define MD_FLOATINGSAVEAREA_LOONGARCH64_FPR_COUNT 32
+
+typedef struct {
+  /* 32 64-bit floating point registers, f0..f31 */
+  uint64_t regs[MD_FLOATINGSAVEAREA_LOONGARCH64_FPR_COUNT];
+  uint64_t fcc;
+  uint32_t fcsr;
+} MDFloatingSaveAreaLoongarch64;
+
+typedef struct {
+  /* The next field determines the layout of the structure, and which parts
+   * of it are populated.
+   */
+  uint32_t context_flags;
+  uint32_t _pad0;
+
+  /* 32 64-bit integer registers, r0..r31.
+   * Note the following fixed uses:
+   *   r3 is the stack pointer.
+   *   r1 is the return address.
+   */
+  uint64_t iregs[MD_CONTEXT_LOONGARCH64_GPR_COUNT];
+
+  uint64_t csr_era;
+
+  /* The next field is included with MD_CONTEXT_LOONGARCH64_FLOATING_POINT. */
+  MDFloatingSaveAreaLoongarch64 float_save;
+
+} MDRawContextLOONGARCH64;
+
+/* Indices into iregs for registers with a dedicated or conventional
+ * purpose.
+ */
+enum MDLoongarchRegisterNumbers {
+  MD_CONTEXT_LOONGARCH64_REG_RA = 1,
+  MD_CONTEXT_LOONGARCH64_REG_TP,
+  MD_CONTEXT_LOONGARCH64_REG_SP,
+  MD_CONTEXT_LOONGARCH64_REG_A0,
+  MD_CONTEXT_LOONGARCH64_REG_A1,
+  MD_CONTEXT_LOONGARCH64_REG_A2,
+  MD_CONTEXT_LOONGARCH64_REG_A3,
+  MD_CONTEXT_LOONGARCH64_REG_A4,
+  MD_CONTEXT_LOONGARCH64_REG_A5,
+  MD_CONTEXT_LOONGARCH64_REG_A6,
+  MD_CONTEXT_LOONGARCH64_REG_A7,
+  MD_CONTEXT_LOONGARCH64_REG_T0,
+  MD_CONTEXT_LOONGARCH64_REG_T1,
+  MD_CONTEXT_LOONGARCH64_REG_T2,
+  MD_CONTEXT_LOONGARCH64_REG_T3,
+  MD_CONTEXT_LOONGARCH64_REG_T4,
+  MD_CONTEXT_LOONGARCH64_REG_T5,
+  MD_CONTEXT_LOONGARCH64_REG_T6,
+  MD_CONTEXT_LOONGARCH64_REG_T7,
+  MD_CONTEXT_LOONGARCH64_REG_T8,
+  MD_CONTEXT_LOONGARCH64_REG_X0,
+  MD_CONTEXT_LOONGARCH64_REG_FP,
+  MD_CONTEXT_LOONGARCH64_REG_S0,
+  MD_CONTEXT_LOONGARCH64_REG_S1,
+  MD_CONTEXT_LOONGARCH64_REG_S2,
+  MD_CONTEXT_LOONGARCH64_REG_S3,
+  MD_CONTEXT_LOONGARCH64_REG_S4,
+  MD_CONTEXT_LOONGARCH64_REG_S5,
+  MD_CONTEXT_LOONGARCH64_REG_S6,
+  MD_CONTEXT_LOONGARCH64_REG_S7,
+  MD_CONTEXT_LOONGARCH64_REG_S8,
+};
+
+/*
+ * Breakpad defines for Loongarch64
+ */
+#define MD_CONTEXT_LOONGARCH64 0x00004000
+#define MD_CONTEXT_LOONGARCH64_INTEGER (MD_CONTEXT_LOONGARCH64 | 0x00000002)
+#define MD_CONTEXT_LOONGARCH64_FLOATING_POINT \
+  (MD_CONTEXT_LOONGARCH64 | 0x00000004)
+
+#define MD_CONTEXT_LOONGARCH64_FULL \
+  (MD_CONTEXT_LOONGARCH64_INTEGER | MD_CONTEXT_LOONGARCH64_FLOATING_POINT)
+
+#define MD_CONTEXT_LOONGARCH64_ALL \
+  (MD_CONTEXT_LOONGARCH64_INTEGER | MD_CONTEXT_LOONGARCH64_FLOATING_POINT)
+
+#endif  // GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_LOONGARCH64_H__
diff --git a/src/google_breakpad/common/minidump_format.h b/src/google_breakpad/common/minidump_format.h
index 1526afcea369c659aeb74d826defa430a21da7fd..e92a2cbaaa3a7af30290329822e1cc6bcf3c357e 100644
--- a/src/google_breakpad/common/minidump_format.h
+++ b/src/google_breakpad/common/minidump_format.h
@@ -120,6 +120,7 @@ typedef struct {
 #include "minidump_cpu_riscv.h"
 #include "minidump_cpu_sparc.h"
 #include "minidump_cpu_x86.h"
+#include "minidump_cpu_loongarch64.h"
 
 /*
  * WinVer.h
@@ -686,6 +687,7 @@ typedef enum {
   MD_CPU_ARCHITECTURE_MIPS64    = 0x8004, /* Breakpad-defined value for MIPS64 */
   MD_CPU_ARCHITECTURE_RISCV     = 0x8005, /* Breakpad-defined value for RISCV */
   MD_CPU_ARCHITECTURE_RISCV64   = 0x8006, /* Breakpad-defined value for RISCV64 */
+  MD_CPU_ARCHITECTURE_LOONGARCH64 = 0x8007, /* Breakpad-defined value for LOONGARCH64 */
   MD_CPU_ARCHITECTURE_UNKNOWN   = 0xffff  /* PROCESSOR_ARCHITECTURE_UNKNOWN */
 } MDCPUArchitecture;
 
diff --git a/src/google_breakpad/processor/dump_context.h b/src/google_breakpad/processor/dump_context.h
index 7a1c643e2df81c53f41e5934a167aef70748b81d..4e8c158f9d0d7b075a459c88281495ea2cc1622b 100644
--- a/src/google_breakpad/processor/dump_context.h
+++ b/src/google_breakpad/processor/dump_context.h
@@ -63,6 +63,7 @@ class DumpContext : public DumpObject {
   const MDRawContextX86*     GetContextX86() const;
   const MDRawContextRISCV*   GetContextRISCV() const;
   const MDRawContextRISCV64* GetContextRISCV64() const;
+  const MDRawContextLOONGARCH64* GetContextLOONGARCH64() const;
 
   // A convenience method to get the instruction pointer out of the
   // MDRawContext, since it varies per-CPU architecture.
@@ -90,6 +91,7 @@ class DumpContext : public DumpObject {
   void SetContextMIPS(MDRawContextMIPS* ctx_mips);
   void SetContextRISCV(MDRawContextRISCV* riscv);
   void SetContextRISCV64(MDRawContextRISCV64* riscv64);
+  void SetContextLOONGARCH64(MDRawContextLOONGARCH64* loongarch64);
 
   // Free the CPU-specific context structure.
   void FreeContext();
@@ -110,6 +112,7 @@ class DumpContext : public DumpObject {
     MDRawContextMIPS*    ctx_mips;
     MDRawContextRISCV*   riscv;
     MDRawContextRISCV64* riscv64;
+    MDRawContextLOONGARCH64* loongarch64;
   } context_;
 
   // Store this separately because of the weirdo AMD64 context
diff --git a/src/google_breakpad/processor/stack_frame_cpu.h b/src/google_breakpad/processor/stack_frame_cpu.h
index 91f1d0cb176b1da59b90b906334d006f81a39d85..145b5df68372dd06560735b5f649bd066dc05f54 100644
--- a/src/google_breakpad/processor/stack_frame_cpu.h
+++ b/src/google_breakpad/processor/stack_frame_cpu.h
@@ -514,6 +514,66 @@ struct StackFrameRISCV64 : public StackFrame {
   int context_validity;
 };
 
+struct StackFrameLOONGARCH64 : public StackFrame {
+  enum ContextValidity {
+    CONTEXT_VALID_NONE = 0,
+
+    CONTEXT_VALID_RA = 1UL << 1,
+    CONTEXT_VALID_TP = 1UL << 2,
+    CONTEXT_VALID_SP = 1UL << 3,
+    CONTEXT_VALID_A0 = 1UL << 4,
+    CONTEXT_VALID_A1 = 1UL << 5,
+    CONTEXT_VALID_A2 = 1UL << 6,
+    CONTEXT_VALID_A3 = 1UL << 7,
+    CONTEXT_VALID_A4 = 1UL << 8,
+    CONTEXT_VALID_A5 = 1UL << 9,
+    CONTEXT_VALID_A6 = 1UL << 10,
+    CONTEXT_VALID_A7 = 1UL << 11,
+    CONTEXT_VALID_T0 = 1UL << 12,
+    CONTEXT_VALID_T1 = 1UL << 13,
+    CONTEXT_VALID_T2 = 1UL << 14,
+    CONTEXT_VALID_T3 = 1UL << 15,
+    CONTEXT_VALID_T4 = 1UL << 16,
+    CONTEXT_VALID_T5 = 1UL << 17,
+    CONTEXT_VALID_T6 = 1UL << 18,
+    CONTEXT_VALID_T7 = 1UL << 19,
+    CONTEXT_VALID_T8 = 1UL << 20,
+    CONTEXT_VALID_X0 = 1UL << 21,
+    CONTEXT_VALID_FP = 1UL << 22,
+    CONTEXT_VALID_S0 = 1UL << 23,
+    CONTEXT_VALID_S1 = 1UL << 24,
+    CONTEXT_VALID_S2 = 1UL << 25,
+    CONTEXT_VALID_S3 = 1UL << 26,
+    CONTEXT_VALID_S4 = 1UL << 27,
+    CONTEXT_VALID_S5 = 1UL << 28,
+    CONTEXT_VALID_S6 = 1UL << 29,
+    CONTEXT_VALID_S7 = 1UL << 30,
+    CONTEXT_VALID_S8 = 1UL << 31,
+
+    CONTEXT_VALID_PC = 1UL << 32,
+    CONTEXT_VALID_ALL = ~CONTEXT_VALID_NONE
+  };
+
+  // Return the ContextValidity flag for register rN.
+  static ContextValidity RegisterValidFlag(int n) {
+    return ContextValidity(1 << n);
+  }
+
+  StackFrameLOONGARCH64() : context(), context_validity(CONTEXT_VALID_NONE) {}
+
+  // Register state. This is only fully valid for the topmost frame in a
+  // stack. In other frames, which registers are present depends on what
+  // debugging information were available. Refer to 'context_validity' below.
+  MDRawContextLOONGARCH64 context;
+
+  // For each register in context whose value has been recovered,
+  // the corresponding CONTEXT_VALID_ bit in 'context_validity' is set.
+  //
+  // context_validity's type should actually be ContextValidity, but
+  // type long is used instead. It contains CONTEXT_VALID_PC.
+  long context_validity;
+};
+
 }  // namespace google_breakpad
 
 #endif  // GOOGLE_BREAKPAD_PROCESSOR_STACK_FRAME_CPU_H__
diff --git a/src/processor/dump_context.cc b/src/processor/dump_context.cc
index 93d826c4abf3e197188c85539b002640206f2048..1affcb95dd6bfe105078fc73d0e5eee53bd9e152 100644
--- a/src/processor/dump_context.cc
+++ b/src/processor/dump_context.cc
@@ -161,6 +161,15 @@ const MDRawContextRISCV64* DumpContext::GetContextRISCV64() const {
   return context_.riscv64;
 }
 
+const MDRawContextLOONGARCH64* DumpContext::GetContextLOONGARCH64() const {
+  if (GetContextCPU() != MD_CONTEXT_LOONGARCH64) {
+    BPLOG(ERROR) << "DumpContext cannot get LOONGARCH64 context";
+    return NULL;
+  }
+
+  return context_.loongarch64;
+}
+
 bool DumpContext::GetInstructionPointer(uint64_t* ip) const {
   BPLOG_IF(ERROR, !ip) << "DumpContext::GetInstructionPointer requires |ip|";
   assert(ip);
@@ -203,6 +212,9 @@ bool DumpContext::GetInstructionPointer(uint64_t* ip) const {
   case MD_CONTEXT_RISCV64:
     *ip = GetContextRISCV64()->pc;
     break;
+  case MD_CONTEXT_LOONGARCH64:
+    *ip = GetContextLOONGARCH64()->csr_era;
+    break;
   default:
     // This should never happen.
     BPLOG(ERROR) << "Unknown CPU architecture in GetInstructionPointer";
@@ -253,6 +265,9 @@ bool DumpContext::GetStackPointer(uint64_t* sp) const {
   case MD_CONTEXT_RISCV64:
     *sp = GetContextRISCV64()->sp;
     break;
+  case MD_CONTEXT_LOONGARCH64:
+    *sp = GetContextLOONGARCH64()->iregs[MD_CONTEXT_LOONGARCH64_REG_SP];
+    break;
   default:
     // This should never happen.
     BPLOG(ERROR) << "Unknown CPU architecture in GetStackPointer";
@@ -305,6 +320,10 @@ void DumpContext::SetContextRISCV64(MDRawContextRISCV64* riscv64) {
   context_.riscv64 = riscv64;
 }
 
+void DumpContext::SetContextLOONGARCH64(MDRawContextLOONGARCH64* loongarch64) {
+  context_.loongarch64 = loongarch64;
+}
+
 void DumpContext::FreeContext() {
   switch (GetContextCPU()) {
     case MD_CONTEXT_X86:
@@ -348,6 +367,10 @@ void DumpContext::FreeContext() {
       delete context_.riscv64;
       break;
 
+    case MD_CONTEXT_LOONGARCH64:
+      delete context_.loongarch64;
+      break;
+
     default:
       // There is no context record (valid_ is false) or there's a
       // context record for an unknown CPU (shouldn't happen, only known
@@ -893,6 +916,37 @@ void DumpContext::Print() {
       break;
     }
 
+    case MD_CONTEXT_LOONGARCH64: {
+      const MDRawContextLOONGARCH64* context_loongarch =
+          GetContextLOONGARCH64();
+      const char* const names[] = {
+          "r0", "ra", "tp", "sp", "a0", "a1", "a2", "a3", "a4", "a5", "a6",
+          "a7", "t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7", "t8", "x",
+          "fp", "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8",
+      };
+      printf("MDRawContextLOONGARCH64\n");
+      printf("  context_flags        = 0x%x\n",
+             context_loongarch->context_flags);
+      for (int ireg_index = 0; ireg_index < MD_CONTEXT_LOONGARCH64_GPR_COUNT;
+           ++ireg_index) {
+        printf("  iregs[%-2s]           = 0x%" PRIx64 "\n", names[ireg_index],
+               context_loongarch->iregs[ireg_index]);
+      }
+
+      printf("  csr_era                  = 0x%" PRIx64 "\n",
+             context_loongarch->csr_era);
+      printf("  float_save.fpsr          = 0x%" PRIx64 "\n",
+             context_loongarch->float_save.fcc);
+      printf("  float_save.fpcr          = 0x%" PRIx32 "\n",
+             context_loongarch->float_save.fcsr);
+      for (int fpr_index = 0;
+           fpr_index < MD_FLOATINGSAVEAREA_LOONGARCH64_FPR_COUNT; ++fpr_index) {
+        printf("  float_save.regs[%2d] = 0x%" PRIx64 "\n", fpr_index,
+               context_loongarch->float_save.regs[fpr_index]);
+      }
+      break;
+    }
+
     default: {
       break;
     }
diff --git a/src/processor/minidump.cc b/src/processor/minidump.cc
index 45e4a5246f03fd07af083ba5b93ea44a6a9fe55f..6fd088fc8e64a20dccf7f7b19e643b368412c98d 100644
--- a/src/processor/minidump.cc
+++ b/src/processor/minidump.cc
@@ -109,6 +109,8 @@ bool IsContextSizeUnique(uint32_t context_size) {
     num_matching_contexts++;
   if (context_size == sizeof(MDRawContextRISCV64))
     num_matching_contexts++;
+  if (context_size == sizeof(MDRawContextLOONGARCH64))
+    num_matching_contexts++;
   return num_matching_contexts == 1;
 }
 
@@ -1350,6 +1352,58 @@ bool MinidumpContext::Read(uint32_t expected_size) {
         break;
       }
 
+      case MD_CONTEXT_LOONGARCH64: {
+        if (expected_size != sizeof(MDRawContextLOONGARCH64)) {
+          BPLOG(ERROR) << "MinidumpContext LOONGARCH64 size mismatch, "
+                       << expected_size
+                       << " != " << sizeof(MDRawContextLOONGARCH64);
+          return false;
+        }
+
+        scoped_ptr<MDRawContextLOONGARCH64> context_loongarch(
+            new MDRawContextLOONGARCH64());
+
+        // Set the context_flags member, which has already been read, and
+        // read the rest of the structure beginning with the first member
+        // after context_flags.
+        context_loongarch->context_flags = context_flags;
+
+        size_t flags_size = sizeof(context_loongarch->context_flags);
+        uint8_t* context_after_flags =
+            reinterpret_cast<uint8_t*>(context_loongarch.get()) + flags_size;
+        if (!minidump_->ReadBytes(
+                context_after_flags,
+                sizeof(MDRawContextLOONGARCH64) - flags_size)) {
+          BPLOG(ERROR) << "MinidumpContext could not read LOONGARCH64 context";
+          return false;
+        }
+
+        // Do this after reading the entire MDRawContext structure because
+        // GetSystemInfo may seek minidump to a new position.
+        if (!CheckAgainstSystemInfo(cpu_type)) {
+          BPLOG(ERROR)
+              << "MinidumpContext LOONGARCH64 does not match system info";
+          return false;
+        }
+
+        if (minidump_->swap()) {
+          // context_loongarch->context_flags was already swapped.
+          for (int ireg_index = 0;
+               ireg_index < MD_CONTEXT_LOONGARCH64_GPR_COUNT; ++ireg_index) {
+            Swap(&context_loongarch->iregs[ireg_index]);
+          }
+          Swap(&context_loongarch->csr_era);
+          for (int fpr_index = 0;
+               fpr_index < MD_FLOATINGSAVEAREA_LOONGARCH64_FPR_COUNT;
+               ++fpr_index) {
+            Swap(&context_loongarch->float_save.regs[fpr_index]);
+          }
+        }
+        SetContextLOONGARCH64(context_loongarch.release());
+
+        break;
+      }
+
       default: {
         // Unknown context type - Don't log as an error yet. Let the
         // caller work that out.
@@ -1452,6 +1506,11 @@ bool MinidumpContext::CheckAgainstSystemInfo(uint32_t context_cpu_type) {
       if (system_info_cpu_type == MD_CPU_ARCHITECTURE_RISCV64)
         return_value = true;
       break;
+
+    case MD_CONTEXT_LOONGARCH64:
+      if (system_info_cpu_type == MD_CPU_ARCHITECTURE_LOONGARCH64)
+        return_value = true;
+      break;
   }
 
   BPLOG_IF(ERROR, !return_value) << "MinidumpContext CPU " <<
@@ -5660,6 +5719,9 @@ bool Minidump::GetContextCPUFlagsFromSystemInfo(uint32_t* context_cpu_flags) {
       case MD_CPU_ARCHITECTURE_RISCV64:
         *context_cpu_flags = MD_CONTEXT_RISCV64;
         break;
+      case MD_CPU_ARCHITECTURE_LOONGARCH64:
+        *context_cpu_flags = MD_CONTEXT_LOONGARCH64;
+        break;
       case MD_CPU_ARCHITECTURE_UNKNOWN:
         *context_cpu_flags = 0;
         break;
diff --git a/src/processor/minidump_processor.cc b/src/processor/minidump_processor.cc
index 5ba6ff4f85121fff713bfbc15a3d5c6804f390bc..78bb6fcad0af06e59f4858a9c8026fb3eaeef37b 100644
--- a/src/processor/minidump_processor.cc
+++ b/src/processor/minidump_processor.cc
@@ -428,6 +428,7 @@ static uint64_t GetAddressForArchitecture(const MDCPUArchitecture architecture,
     case MD_CPU_ARCHITECTURE_SHX:
     case MD_CPU_ARCHITECTURE_ARM:
     case MD_CPU_ARCHITECTURE_X86_WIN64:
+    case MD_CPU_ARCHITECTURE_LOONGARCH64:
       // 32-bit architectures, mask the upper bits.
       return raw_address & 0xffffffffULL;
 
@@ -643,6 +644,11 @@ bool MinidumpProcessor::GetCPUInfo(Minidump* dump, SystemInfo* info) {
       break;
     }
 
+    case MD_CPU_ARCHITECTURE_LOONGARCH64: {
+      info->cpu = "loongarch64";
+      break;
+    }
+
     default: {
       // Assign the numeric architecture ID into the CPU string.
       char cpu_string[7];
diff --git a/src/processor/stackwalk_common.cc b/src/processor/stackwalk_common.cc
index 688b27823ec2d0a7df051b8dd736ff27fe2cdb6b..c1c0212f084fe81ccd997b1712d2454383c2bd81 100644
--- a/src/processor/stackwalk_common.cc
+++ b/src/processor/stackwalk_common.cc
@@ -935,6 +935,210 @@ static void PrintStack(const CallStack* stack,
             StackFrameRISCV64::CONTEXT_VALID_T6)
           sequence = PrintRegister64(
               "t6", frame_riscv64->context.t6, sequence);
+      } else if (cpu == "loongarch64") {
+        const StackFrameLOONGARCH64* frame_loongarch =
+            reinterpret_cast<const StackFrameLOONGARCH64*>(frame);
+
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_RA)
+          sequence = PrintRegister64(
+              "ra",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_RA],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_TP)
+          sequence = PrintRegister64(
+              "tp",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_TP],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_SP)
+          sequence = PrintRegister64(
+              "sp",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP],
+              sequence);
+
+        // Save registers a0-a7
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_A0)
+          sequence = PrintRegister64(
+              "a0",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_A0],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_A1)
+          sequence = PrintRegister64(
+              "a1",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_A1],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_A2)
+          sequence = PrintRegister64(
+              "a2",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_A2],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_A3)
+          sequence = PrintRegister64(
+              "a3",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_A3],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_A4)
+          sequence = PrintRegister64(
+              "a4",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_A4],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_A5)
+          sequence = PrintRegister64(
+              "a5",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_A5],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_A6)
+          sequence = PrintRegister64(
+              "a6",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_A6],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_A7)
+          sequence = PrintRegister64(
+              "a7",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_A7],
+              sequence);
+
+        // Save registers t0-s8
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_T0)
+          sequence = PrintRegister64(
+              "t0",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_T0],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_T1)
+          sequence = PrintRegister64(
+              "t1",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_T1],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_T2)
+          sequence = PrintRegister64(
+              "t2",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_T2],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_T3)
+          sequence = PrintRegister64(
+              "t3",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_T3],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_T4)
+          sequence = PrintRegister64(
+              "t4",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_T4],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_T5)
+          sequence = PrintRegister64(
+              "t5",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_T5],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_T6)
+          sequence = PrintRegister64(
+              "t6",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_T6],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_T7)
+          sequence = PrintRegister64(
+              "t7",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_T7],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_T8)
+          sequence = PrintRegister64(
+              "t8",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_T8],
+              sequence);
+
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_X0)
+          sequence = PrintRegister64(
+              "x0",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_X0],
+              sequence);
+
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_FP)
+          sequence = PrintRegister64(
+              "fp",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_FP],
+              sequence);
+
+        // Save registers s0-s8
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_S0)
+          sequence = PrintRegister64(
+              "s0",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S0],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_S1)
+          sequence = PrintRegister64(
+              "s1",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S1],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_S2)
+          sequence = PrintRegister64(
+              "s2",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S2],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_S3)
+          sequence = PrintRegister64(
+              "s3",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S3],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_S4)
+          sequence = PrintRegister64(
+              "s4",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S4],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_S5)
+          sequence = PrintRegister64(
+              "s5",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S5],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_S6)
+          sequence = PrintRegister64(
+              "s6",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S6],
+              sequence);
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_S7)
+          sequence = PrintRegister64(
+              "s7",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S7],
+              sequence);
+
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_S8)
+          sequence = PrintRegister64(
+              "s8",
+              frame_loongarch->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S8],
+              sequence);
+
+        if (frame_loongarch->context_validity &
+            StackFrameLOONGARCH64::CONTEXT_VALID_PC)
+          sequence =
+              PrintRegister64("pc", frame_loongarch->context.csr_era, sequence);
       }
     }
     printf("\n    Found by: %s\n", frame->trust_description().c_str());
diff --git a/src/processor/stackwalker.cc b/src/processor/stackwalker.cc
index 1ff6cf7cb91a3417b61e1d72d5a9f12e07cebbe9..9cd5729d01e7aab0e10d25bc743a392e70fa2d94 100644
--- a/src/processor/stackwalker.cc
+++ b/src/processor/stackwalker.cc
@@ -60,6 +60,7 @@
 #include "processor/stackwalker_mips.h"
 #include "processor/stackwalker_riscv.h"
 #include "processor/stackwalker_riscv64.h"
+#include "processor/stackwalker_loongarch64.h"
 
 namespace google_breakpad {
 
@@ -290,6 +291,12 @@ Stackwalker* Stackwalker::StackwalkerForCPU(
                                                memory, modules,
                                                frame_symbolizer);
       break;
+
+    case MD_CONTEXT_LOONGARCH64:
+      cpu_stackwalker = new StackwalkerLOONGARCH64(
+          system_info, context->GetContextLOONGARCH64(), memory, modules,
+          frame_symbolizer);
+      break;
   }
 
   BPLOG_IF(ERROR, !cpu_stackwalker) << "Unknown CPU type " << HexString(cpu) <<
diff --git a/src/processor/stackwalker_loongarch64.cc b/src/processor/stackwalker_loongarch64.cc
new file mode 100644
index 0000000000000000000000000000000000000000..974912eabd72d65681ff7df983d55980bc747c62
--- /dev/null
+++ b/src/processor/stackwalker_loongarch64.cc
@@ -0,0 +1,288 @@
+// Copyright 2013 Google LLC
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google LLC nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// stackwalker_loongarch64.cc: LOONGARCH64-specific stackwalker.
+//
+// See stackwalker_loongarch64.h for documentation.
+
+#include "processor/stackwalker_loongarch64.h"
+#include "common/scoped_ptr.h"
+#include "google_breakpad/common/minidump_cpu_loongarch64.h"
+#include "google_breakpad/processor/call_stack.h"
+#include "google_breakpad/processor/code_modules.h"
+#include "google_breakpad/processor/memory_region.h"
+#include "google_breakpad/processor/source_line_resolver_interface.h"
+#include "google_breakpad/processor/stack_frame_cpu.h"
+#include "processor/cfi_frame_info.h"
+#include "processor/logging.h"
+#include "processor/postfix_evaluator-inl.h"
+#include "processor/windows_frame_info.h"
+
+namespace google_breakpad {
+
+StackwalkerLOONGARCH64::StackwalkerLOONGARCH64(
+    const SystemInfo* system_info,
+    const MDRawContextLOONGARCH64* context,
+    MemoryRegion* memory,
+    const CodeModules* modules,
+    StackFrameSymbolizer* resolver_helper)
+    : Stackwalker(system_info, memory, modules, resolver_helper),
+      context_(context) {
+  if (memory_) {
+    if (0xffffffffffffffff - memory_->GetBase() < memory_->GetSize() - 1) {
+      BPLOG(ERROR) << "Memory out of range for stackwalking loongarch64: "
+                   << HexString(memory_->GetBase()) << "+"
+                   << HexString(memory_->GetSize());
+      memory_ = NULL;
+    }
+  }
+}
+
+StackFrame* StackwalkerLOONGARCH64::GetContextFrame() {
+  if (!context_) {
+    BPLOG(ERROR) << "Can't get context frame without context.";
+    return NULL;
+  }
+
+  StackFrameLOONGARCH64* frame = new StackFrameLOONGARCH64();
+
+  // The instruction pointer is stored directly in a register, so pull it
+  // straight out of the CPU context structure.
+  frame->context = *context_;
+  frame->context_validity = StackFrameLOONGARCH64::CONTEXT_VALID_ALL;
+  frame->trust = StackFrame::FRAME_TRUST_CONTEXT;
+  frame->instruction = frame->context.csr_era;
+
+  return frame;
+}
+
+// Register names for loongarch.
+static const char* const kRegisterNames[] = {
+    "$zero", "$ra",  "$tp",   "$sp",   "$a0",   "$a1",   "$a2",   "$a3",
+    "$a4",   "$a5",  "$a6",   "$a7",   "$t0",   "$t1",   "$t2",   "$t3",
+    "$t4",   "$t5",  "$t6",   "$t7",   "$t8",   "$x",    "$fp",   "$s0",
+    "$s1",   "$s2",  "$s3",   "$s4",   "$s5",   "$s6",   "$s7",   "$s8",
+    "$fa0",  "$fa1", "$fa2",  "$fa3",  "$fa4",  "$fa5",  "$fa6",  "$fa7",
+    "$ft0",  "$ft1", "$ft2",  "$ft3",  "$ft4",  "$ft5",  "$ft6",  "$ft7",
+    "$ft8",  "$ft9", "$ft10", "$ft11", "$ft12", "$ft13", "$ft14", "$ft15",
+    "$fs0",  "$fs1", "$fs2",  "$fs3",  "$fs4",  "$fs5",  "$fs6",  "$fs7",
+    NULL};
+
+StackFrameLOONGARCH64* StackwalkerLOONGARCH64::GetCallerByCFIFrameInfo(
+    const vector<StackFrame*>& frames,
+    CFIFrameInfo* cfi_frame_info) {
+  StackFrameLOONGARCH64* last_frame =
+      static_cast<StackFrameLOONGARCH64*>(frames.back());
+
+  uint64_t pc = 0;
+
+  // Populate a dictionary with the valid register values in last_frame.
+  CFIFrameInfo::RegisterValueMap<uint64_t> callee_registers;
+  // Use the STACK CFI data to recover the caller's register values.
+  CFIFrameInfo::RegisterValueMap<uint64_t> caller_registers;
+
+  for (int i = 0; kRegisterNames[i]; ++i) {
+    caller_registers[kRegisterNames[i]] = last_frame->context.iregs[i];
+    callee_registers[kRegisterNames[i]] = last_frame->context.iregs[i];
+  }
+
+  if (!cfi_frame_info->FindCallerRegs(callee_registers, *memory_,
+                                      &caller_registers)) {
+    return NULL;
+  }
+
+  CFIFrameInfo::RegisterValueMap<uint64_t>::const_iterator entry =
+      caller_registers.find(".cfa");
+
+  if (!caller_registers["$sp"] && entry != caller_registers.end()) {
+    caller_registers["$sp"] = entry->second;
+  }
+
+  entry = caller_registers.find(".ra");
+  if (entry != caller_registers.end()) {
+    caller_registers["$ra"] = entry->second;
+    pc = entry->second;
+  }
+  caller_registers["$pc"] = pc;
+  // Construct a new stack frame given the values the CFI recovered.
+  scoped_ptr<StackFrameLOONGARCH64> frame(new StackFrameLOONGARCH64());
+
+  for (int i = 0; kRegisterNames[i]; ++i) {
+    CFIFrameInfo::RegisterValueMap<uint64_t>::const_iterator caller_entry =
+        caller_registers.find(kRegisterNames[i]);
+
+    if (caller_entry != caller_registers.end()) {
+      // The value of this register is recovered; fill the context with the
+      // value from caller_registers.
+      frame->context.iregs[i] = caller_entry->second;
+      frame->context_validity |= StackFrameLOONGARCH64::RegisterValidFlag(i);
+    } else {
+      // If the STACK CFI data doesn't mention some callee-save register, and
+      // it is valid in the callee, assume the callee has not yet changed it.
+      // Calee-save registers according to the loongarch psABI specification
+      // are: $s0 to $s8, $fp, $sp
+      frame->context.iregs[i] = last_frame->context.iregs[i];
+      frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_S0;
+      frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_S1;
+      frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_S2;
+      frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_S3;
+      frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_S4;
+      frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_S5;
+      frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_S6;
+      frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_S7;
+      frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_S8;
+      frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_FP;
+      frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_SP;
+    }
+  }
+
+  frame->context.csr_era = caller_registers["$pc"];
+  frame->instruction = caller_registers["$pc"];
+  frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_PC;
+
+  frame->context.iregs[MD_CONTEXT_LOONGARCH64_REG_RA] = caller_registers["$ra"];
+  frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_RA;
+
+  frame->trust = StackFrame::FRAME_TRUST_CFI;
+
+  return frame.release();
+}
+
+StackFrame* StackwalkerLOONGARCH64::GetCallerFrame(const CallStack* stack,
+                                                   bool stack_scan_allowed) {
+  if (!memory_ || !stack) {
+    BPLOG(ERROR) << "Can't get caller frame without memory or stack";
+    return NULL;
+  }
+
+  const vector<StackFrame*>& frames = *stack->frames();
+  StackFrameLOONGARCH64* last_frame =
+      static_cast<StackFrameLOONGARCH64*>(frames.back());
+  scoped_ptr<StackFrameLOONGARCH64> new_frame;
+
+  // See if there is DWARF call frame information covering this address.
+  scoped_ptr<CFIFrameInfo> cfi_frame_info(
+      frame_symbolizer_->FindCFIFrameInfo(last_frame));
+  if (cfi_frame_info.get())
+    new_frame.reset(GetCallerByCFIFrameInfo(frames, cfi_frame_info.get()));
+
+  // If caller frame is not found in CFI try analyzing the stack.
+  if (stack_scan_allowed && !new_frame.get()) {
+    new_frame.reset(GetCallerByStackScan(frames));
+  }
+
+  // If nothing worked, tell the caller.
+  if (!new_frame.get()) {
+    return NULL;
+  }
+
+  // Should we terminate the stack walk? (end-of-stack or broken invariant)
+  if (TerminateWalk(new_frame->context.csr_era,
+                    new_frame->context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP],
+                    last_frame->context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP],
+                    frames.size() == 1)) {
+    return NULL;
+  }
+
+  return new_frame.release();
+}
+
+StackFrameLOONGARCH64* StackwalkerLOONGARCH64::GetCallerByStackScan(
+    const vector<StackFrame*>& frames) {
+  const uint32_t kMaxFrameStackSize = 1024;
+
+  StackFrameLOONGARCH64* last_frame =
+      static_cast<StackFrameLOONGARCH64*>(frames.back());
+
+  uint64_t last_sp = last_frame->context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP];
+  uint64_t caller_pc, caller_sp, caller_fp;
+
+  // Return address cannot be obtained directly.
+  // Force stackwalking.
+
+  // We cannot use frame pointer to get the return address.
+  // We'll scan the stack for a
+  // return address. This can happen if last_frame is executing code
+  // for a module for which we don't have symbols.
+  int count = kMaxFrameStackSize / sizeof(caller_pc);
+
+  do {
+    // Scanning for return address from stack pointer of the last frame.
+    if (!ScanForReturnAddress(last_sp, &caller_sp, &caller_pc, count)) {
+      // If we can't find an instruction pointer even with stack scanning,
+      // give up.
+      return NULL;
+    }
+    // Get $fp stored in the stack frame.
+    if (!memory_->GetMemoryAtAddress(caller_sp - sizeof(caller_pc),
+                                     &caller_fp)) {
+      BPLOG(INFO) << " GetMemoryAtAddress for fp failed ";
+      return NULL;
+    }
+
+    count = count - (caller_sp - last_sp) / sizeof(caller_pc);
+    // Now scan the next address in the stack.
+    last_sp = caller_sp + sizeof(caller_pc);
+  } while ((caller_fp - caller_sp >= kMaxFrameStackSize) && count > 0);
+
+  if (!count) {
+    BPLOG(INFO) << " No frame found ";
+    return NULL;
+  }
+
+  // ScanForReturnAddress found a reasonable return address. Advance
+  // $sp to the location above the one where the return address was
+  // found.
+  caller_sp += sizeof(caller_pc);
+  // caller_pc is actually containing $ra value;
+  // $pc is two instructions before $ra,
+  // so the caller_pc needs to be decremented accordingly.
+  caller_pc -= sizeof(caller_pc);
+
+  // Create a new stack frame (ownership will be transferred to the caller)
+  // and fill it in.
+  StackFrameLOONGARCH64* frame = new StackFrameLOONGARCH64();
+  frame->trust = StackFrame::FRAME_TRUST_SCAN;
+  frame->context = last_frame->context;
+  frame->context.csr_era = caller_pc;
+  frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_PC;
+  frame->instruction = caller_pc;
+
+  frame->context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP] = caller_sp;
+  frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_SP;
+  frame->context.iregs[MD_CONTEXT_LOONGARCH64_REG_FP] = caller_fp;
+  frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_FP;
+
+  frame->context.iregs[MD_CONTEXT_LOONGARCH64_REG_RA] =
+      caller_pc + sizeof(caller_pc);
+  frame->context_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_RA;
+
+  return frame;
+}
+
+}  // namespace google_breakpad
diff --git a/src/processor/stackwalker_loongarch64.h b/src/processor/stackwalker_loongarch64.h
new file mode 100644
index 0000000000000000000000000000000000000000..1416f49f5b0c8f88c2b98a64c6741c46343ea898
--- /dev/null
+++ b/src/processor/stackwalker_loongarch64.h
@@ -0,0 +1,85 @@
+// Copyright 2013 Google LLC
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google LLC nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// stackwalker_loongarch64.h: LOONGARCH64-specific stackwalker.
+//
+// Provides stack frames given LOONGARCH64 register context and a memory region
+// corresponding to a LOONGARCH64 stack.
+
+#ifndef PROCESSOR_STACKWALKER_LOONGARCH64_H__
+#define PROCESSOR_STACKWALKER_LOONGARCH64_H__
+
+#include "google_breakpad/common/breakpad_types.h"
+#include "google_breakpad/common/minidump_format.h"
+#include "google_breakpad/processor/stack_frame_cpu.h"
+#include "google_breakpad/processor/stackwalker.h"
+#include "processor/cfi_frame_info.h"
+
+namespace google_breakpad {
+
+class CodeModules;
+
+class StackwalkerLOONGARCH64 : public Stackwalker {
+ public:
+  // Context is a loongarch64 context object that gives access to
+  // loongarch64-specific register state corresponding to the innermost
+  // called frame to be included in the stack.  The other arguments are
+  // passed directly through to the base Stackwalker constructor.
+  StackwalkerLOONGARCH64(const SystemInfo* system_info,
+                         const MDRawContextLOONGARCH64* context,
+                         MemoryRegion* memory,
+                         const CodeModules* modules,
+                         StackFrameSymbolizer* frame_symbolizer);
+
+ private:
+  // Implementation of Stackwalker, using loongarch64 context and stack
+  // conventions.
+  virtual StackFrame* GetContextFrame();
+  virtual StackFrame* GetCallerFrame(const CallStack* stack,
+                                     bool stack_scan_allowed);
+
+  // Use cfi_frame_info (derived from STACK CFI records) to construct
+  // the frame that called frames.back(). The caller takes ownership
+  // of the returned frame. Return NULL on failure.
+  StackFrameLOONGARCH64* GetCallerByCFIFrameInfo(
+      const vector<StackFrame*>& frames,
+      CFIFrameInfo* cfi_frame_info);
+
+  // Scan the stack for plausible return address and frame pointer pair.
+  // The caller takes ownership of the returned frame. Return NULL on failure.
+  StackFrameLOONGARCH64* GetCallerByStackScan(
+      const vector<StackFrame*>& frames);
+
+  // Stores the CPU context corresponding to the innermost stack frame to
+  // be returned by GetContextFrame.
+  const MDRawContextLOONGARCH64* context_;
+};
+
+}  // namespace google_breakpad
+
+#endif  // PROCESSOR_STACKWALKER_LOONGARCH64_H__
diff --git a/src/processor/stackwalker_loongarch64_unittest.cc b/src/processor/stackwalker_loongarch64_unittest.cc
new file mode 100644
index 0000000000000000000000000000000000000000..756548f81c02519b9570090b078d08beb0e532a5
--- /dev/null
+++ b/src/processor/stackwalker_loongarch64_unittest.cc
@@ -0,0 +1,818 @@
+// Copyright 2013 Google LLC
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google LLC nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// stackwalker_loongarch64_unittest.cc: Unit tests for StackwalkerLOONGARCH64
+// class for loongarch64 platforms.
+#include <string.h>
+#include <string>
+#include <vector>
+
+#include "breakpad_googletest_includes.h"
+#include "common/test_assembler.h"
+#include "common/using_std_string.h"
+#include "google_breakpad/common/minidump_format.h"
+#include "google_breakpad/processor/basic_source_line_resolver.h"
+#include "google_breakpad/processor/call_stack.h"
+#include "google_breakpad/processor/code_module.h"
+#include "google_breakpad/processor/source_line_resolver_interface.h"
+#include "google_breakpad/processor/stack_frame_cpu.h"
+#include "processor/stackwalker_loongarch64.h"
+#include "processor/stackwalker_unittest_utils.h"
+#include "processor/windows_frame_info.h"
+
+using google_breakpad::BasicSourceLineResolver;
+using google_breakpad::CallStack;
+using google_breakpad::CodeModule;
+using google_breakpad::StackFrame;
+using google_breakpad::StackFrameLOONGARCH64;
+using google_breakpad::StackFrameSymbolizer;
+using google_breakpad::Stackwalker;
+using google_breakpad::StackwalkerLOONGARCH64;
+using google_breakpad::SystemInfo;
+using google_breakpad::WindowsFrameInfo;
+using google_breakpad::test_assembler::kLittleEndian;
+using google_breakpad::test_assembler::Label;
+using google_breakpad::test_assembler::Section;
+using std::vector;
+using testing::_;
+using testing::AnyNumber;
+using testing::DoAll;
+using testing::Return;
+using testing::SetArgumentPointee;
+using testing::Test;
+
+class StackwalkerLOONGARCH64Fixture {
+ public:
+  StackwalkerLOONGARCH64Fixture()
+      : stack_section(kLittleEndian),
+        // Give the two modules reasonable standard locations and names
+        // for tests to play with.
+        module1(0x40000000, 0x10000, "module1", "version1"),
+        module2(0x50000000, 0x10000, "module2", "version2") {
+    // Identify the system as an iOS system.
+    system_info.os = "Linux";
+    system_info.os_short = "linux";
+    system_info.cpu = "loongarch64";
+    system_info.cpu_info = "";
+
+    // Put distinctive values in the raw CPU context.
+    BrandContext(&raw_context);
+
+    // Create some modules with some stock debugging information.
+    modules.Add(&module1);
+    modules.Add(&module2);
+
+    // By default, none of the modules have symbol info; call
+    // SetModuleSymbols to override this.
+    EXPECT_CALL(supplier, GetCStringSymbolData(_, _, _, _, _))
+        .WillRepeatedly(Return(MockSymbolSupplier::NOT_FOUND));
+
+    // Avoid GMOCK WARNING "Uninteresting mock function call - returning
+    // directly" for FreeSymbolData().
+    EXPECT_CALL(supplier, FreeSymbolData(_)).Times(AnyNumber());
+
+    // Reset max_frames_scanned since it's static.
+    Stackwalker::set_max_frames_scanned(1024);
+  }
+
+  // Set the Breakpad symbol information that supplier should return for
+  // MODULE to INFO.
+  void SetModuleSymbols(MockCodeModule* module, const string& info) {
+    size_t buffer_size;
+    char* buffer = supplier.CopySymbolDataAndOwnTheCopy(info, &buffer_size);
+    EXPECT_CALL(supplier, GetCStringSymbolData(module, &system_info, _, _, _))
+        .WillRepeatedly(DoAll(SetArgumentPointee<3>(buffer),
+                              SetArgumentPointee<4>(buffer_size),
+                              Return(MockSymbolSupplier::FOUND)));
+  }
+
+  // Populate stack_region with the contents of stack_section. Use
+  // stack_section.start() as the region's starting address.
+  void RegionFromSection() {
+    string contents;
+    ASSERT_TRUE(stack_section.GetContents(&contents));
+    stack_region.Init(stack_section.start().Value(), contents);
+  }
+
+  // Fill RAW_CONTEXT with pseudo-random data, for round-trip checking.
+  void BrandContext(MDRawContextLOONGARCH64* raw_context) {
+    uint8_t x = 173;
+    for (size_t i = 0; i < sizeof(*raw_context); i++)
+      reinterpret_cast<uint8_t*>(raw_context)[i] = (x += 17);
+  }
+
+  SystemInfo system_info;
+  MDRawContextLOONGARCH64 raw_context;
+  Section stack_section;
+  MockMemoryRegion stack_region;
+  MockCodeModule module1;
+  MockCodeModule module2;
+  MockCodeModules modules;
+  MockSymbolSupplier supplier;
+  BasicSourceLineResolver resolver;
+  CallStack call_stack;
+  const vector<StackFrame*>* frames;
+};
+
+class SanityCheck : public StackwalkerLOONGARCH64Fixture, public Test {};
+
+TEST_F(SanityCheck, NoResolver) {
+  // Since the context's frame pointer is garbage, the stack walk will end after
+  // the first frame.
+  StackFrameSymbolizer frame_symbolizer(NULL, NULL);
+  StackwalkerLOONGARCH64 walker(&system_info, &raw_context, &stack_region,
+                                &modules, &frame_symbolizer);
+  // This should succeed even without a resolver or supplier.
+  vector<const CodeModule*> modules_without_symbols;
+  vector<const CodeModule*> modules_with_corrupt_symbols;
+  ASSERT_TRUE(walker.Walk(&call_stack, &modules_without_symbols,
+                          &modules_with_corrupt_symbols));
+  ASSERT_EQ(0U, modules_without_symbols.size());
+  ASSERT_EQ(0U, modules_with_corrupt_symbols.size());
+  frames = call_stack.frames();
+  ASSERT_EQ(1U, frames->size());
+  StackFrameLOONGARCH64* frame =
+      static_cast<StackFrameLOONGARCH64*>(frames->at(0));
+  // Check that the values from the original raw context made it
+  // through to the context in the stack frame.
+  EXPECT_EQ(0, memcmp(&raw_context, &frame->context, sizeof(raw_context)));
+}
+
+class GetContextFrame : public StackwalkerLOONGARCH64Fixture, public Test {};
+
+// The stackwalker should be able to produce the context frame even
+// without stack memory present.
+TEST_F(GetContextFrame, NoStackMemory) {
+  StackFrameSymbolizer frame_symbolizer(&supplier, &resolver);
+  StackwalkerLOONGARCH64 walker(&system_info, &raw_context, NULL, &modules,
+                                &frame_symbolizer);
+  vector<const CodeModule*> modules_without_symbols;
+  vector<const CodeModule*> modules_with_corrupt_symbols;
+  ASSERT_TRUE(walker.Walk(&call_stack, &modules_without_symbols,
+                          &modules_with_corrupt_symbols));
+  ASSERT_EQ(0U, modules_without_symbols.size());
+  ASSERT_EQ(0U, modules_with_corrupt_symbols.size());
+  frames = call_stack.frames();
+  ASSERT_EQ(1U, frames->size());
+  StackFrameLOONGARCH64* frame =
+      static_cast<StackFrameLOONGARCH64*>(frames->at(0));
+  // Check that the values from the original raw context made it
+  // through to the context in the stack frame.
+  EXPECT_EQ(0, memcmp(&raw_context, &frame->context, sizeof(raw_context)));
+}
+
+class GetCallerFrame : public StackwalkerLOONGARCH64Fixture, public Test {};
+
+TEST_F(GetCallerFrame, ScanWithoutSymbols) {
+  // When the stack walker resorts to scanning the stack,
+  // only addresses located within loaded modules are
+  // considered valid return addresses.
+  // Force scanning through three frames to ensure that the
+  // stack pointer is set properly in scan-recovered frames.
+  stack_section.start() = 0x80000000;
+  uint64_t return_address1 = 0x50000100;
+  uint64_t return_address2 = 0x50000900;
+  Label frame1_sp, frame2_sp;
+  stack_section
+      // frame 0
+      .Append(32, 0)  // space
+
+      .D64(0x40090000)  // junk that's not
+      .D64(0x60000000)  // a return address
+
+      .D64(frame1_sp)        // stack pointer
+      .D64(return_address1)  // actual return address
+      // frame 1
+      .Mark(&frame1_sp)
+      .Append(32, 0)  // space
+
+      .D64(0xF0000000)  // more junk
+      .D64(0x0000000D)
+
+      .D64(frame2_sp)        // stack pointer
+      .D64(return_address2)  // actual return address
+      // frame 2
+      .Mark(&frame2_sp)
+      .Append(64, 0);  // end of stack
+  RegionFromSection();
+
+  raw_context.csr_era = 0x40005510;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP] =
+      stack_section.start().Value();
+
+  StackFrameSymbolizer frame_symbolizer(&supplier, &resolver);
+  StackwalkerLOONGARCH64 walker(&system_info, &raw_context, &stack_region,
+                                &modules, &frame_symbolizer);
+  vector<const CodeModule*> modules_without_symbols;
+  vector<const CodeModule*> modules_with_corrupt_symbols;
+  ASSERT_TRUE(walker.Walk(&call_stack, &modules_without_symbols,
+                          &modules_with_corrupt_symbols));
+  ASSERT_EQ(2U, modules_without_symbols.size());
+  ASSERT_EQ("module1", modules_without_symbols[0]->debug_file());
+  ASSERT_EQ("module2", modules_without_symbols[1]->debug_file());
+  ASSERT_EQ(0U, modules_with_corrupt_symbols.size());
+  frames = call_stack.frames();
+  ASSERT_EQ(3U, frames->size());
+
+  StackFrameLOONGARCH64* frame0 =
+      static_cast<StackFrameLOONGARCH64*>(frames->at(0));
+  EXPECT_EQ(StackFrame::FRAME_TRUST_CONTEXT, frame0->trust);
+  ASSERT_EQ(StackFrameLOONGARCH64::CONTEXT_VALID_ALL, frame0->context_validity);
+  EXPECT_EQ(0, memcmp(&raw_context, &frame0->context, sizeof(raw_context)));
+
+  StackFrameLOONGARCH64* frame1 =
+      static_cast<StackFrameLOONGARCH64*>(frames->at(1));
+  EXPECT_EQ(StackFrame::FRAME_TRUST_SCAN, frame1->trust);
+  ASSERT_EQ((StackFrameLOONGARCH64::CONTEXT_VALID_PC |
+             StackFrameLOONGARCH64::CONTEXT_VALID_SP |
+             StackFrameLOONGARCH64::CONTEXT_VALID_FP |
+             StackFrameLOONGARCH64::CONTEXT_VALID_RA),
+            frame1->context_validity);
+  EXPECT_EQ(return_address1 - sizeof(return_address1), frame1->context.csr_era);
+  EXPECT_EQ(frame1_sp.Value(),
+            frame1->context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP]);
+
+  StackFrameLOONGARCH64* frame2 =
+      static_cast<StackFrameLOONGARCH64*>(frames->at(2));
+  EXPECT_EQ(StackFrame::FRAME_TRUST_SCAN, frame2->trust);
+  ASSERT_EQ((StackFrameLOONGARCH64::CONTEXT_VALID_PC |
+             StackFrameLOONGARCH64::CONTEXT_VALID_SP |
+             StackFrameLOONGARCH64::CONTEXT_VALID_FP |
+             StackFrameLOONGARCH64::CONTEXT_VALID_RA),
+            frame2->context_validity);
+  EXPECT_EQ(return_address2 - sizeof(return_address2), frame2->context.csr_era);
+  EXPECT_EQ(frame2_sp.Value(),
+            frame2->context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP]);
+}
+
+TEST_F(GetCallerFrame, ScanWithFunctionSymbols) {
+  // During stack scanning, if a potential return address
+  // is located within a loaded module that has symbols,
+  // it is only considered a valid return address if it
+  // lies within a function's bounds.
+  stack_section.start() = 0x80000000;
+  uint64_t return_address = 0x50000200;
+  Label frame1_sp;
+
+  stack_section
+      // frame 0
+      .Append(32, 0)  // space
+
+      .D64(0x40090000)  // junk that's not
+      .D64(0x60000000)  // a return address
+
+      .D64(0x40001000)  // a couple of plausible addresses
+      .D64(0x5000F000)  // that are not within functions
+
+      .D64(frame1_sp)       // stack pointer
+      .D64(return_address)  // actual return address
+      // frame 1
+      .Mark(&frame1_sp)
+      .Append(64, 0);  // end of stack
+  RegionFromSection();
+
+  raw_context.csr_era = 0x40000200;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP] =
+      stack_section.start().Value();
+
+  SetModuleSymbols(&module1,
+                   // The youngest frame's function.
+                   "FUNC 100 400 10 monotreme\n");
+  SetModuleSymbols(&module2,
+                   // The calling frame's function.
+                   "FUNC 100 400 10 marsupial\n");
+
+  StackFrameSymbolizer frame_symbolizer(&supplier, &resolver);
+  StackwalkerLOONGARCH64 walker(&system_info, &raw_context, &stack_region,
+                                &modules, &frame_symbolizer);
+  vector<const CodeModule*> modules_without_symbols;
+  vector<const CodeModule*> modules_with_corrupt_symbols;
+  ASSERT_TRUE(walker.Walk(&call_stack, &modules_without_symbols,
+                          &modules_with_corrupt_symbols));
+  ASSERT_EQ(0U, modules_without_symbols.size());
+  ASSERT_EQ(0U, modules_with_corrupt_symbols.size());
+  frames = call_stack.frames();
+  ASSERT_EQ(2U, frames->size());
+
+  StackFrameLOONGARCH64* frame0 =
+      static_cast<StackFrameLOONGARCH64*>(frames->at(0));
+  EXPECT_EQ(StackFrame::FRAME_TRUST_CONTEXT, frame0->trust);
+  ASSERT_EQ(StackFrameLOONGARCH64::CONTEXT_VALID_ALL, frame0->context_validity);
+  EXPECT_EQ(0, memcmp(&raw_context, &frame0->context, sizeof(raw_context)));
+  EXPECT_EQ("monotreme", frame0->function_name);
+  EXPECT_EQ(0x40000100ULL, frame0->function_base);
+
+  StackFrameLOONGARCH64* frame1 =
+      static_cast<StackFrameLOONGARCH64*>(frames->at(1));
+  EXPECT_EQ(StackFrame::FRAME_TRUST_SCAN, frame1->trust);
+  ASSERT_EQ((StackFrameLOONGARCH64::CONTEXT_VALID_PC |
+             StackFrameLOONGARCH64::CONTEXT_VALID_SP |
+             StackFrameLOONGARCH64::CONTEXT_VALID_FP |
+             StackFrameLOONGARCH64::CONTEXT_VALID_RA),
+            frame1->context_validity);
+  EXPECT_EQ(return_address - sizeof(return_address), frame1->context.csr_era);
+  EXPECT_EQ(frame1_sp.Value(),
+            frame1->context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP]);
+  EXPECT_EQ("marsupial", frame1->function_name);
+  EXPECT_EQ(0x50000100ULL, frame1->function_base);
+}
+
+TEST_F(GetCallerFrame, ScanFirstFrame) {
+  // If the stackwalker resorts to stack scanning, it will scan much
+  // farther to find the caller of the context frame.
+  stack_section.start() = 0x80000000;
+  uint64_t return_address1 = 0x50000100;
+  uint64_t return_address2 = 0x50000900;
+  Label frame1_sp, frame2_sp;
+  stack_section
+      // frame 0
+      .Append(16, 0)  // space
+
+      .D64(0x40090000)  // junk that's not
+      .D64(0x60000000)  // a return address
+
+      .Append(96, 0)  // more space
+
+      .D64(frame1_sp)        // stack pointer
+      .D64(return_address1)  // actual return address
+      // frame 1
+      .Mark(&frame1_sp)
+      .Append(32, 0)  // space
+
+      .D64(0xF0000000)  // more junk
+      .D64(0x0000000D)
+
+      .Append(336, 0)  // more space
+
+      .D64(return_address2)  // actual return address
+      // (won't be found)
+      // frame 2
+      .Mark(&frame2_sp)
+      .Append(64, 0);  // end of stack
+  RegionFromSection();
+
+  raw_context.csr_era = 0x40005510;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP] =
+      stack_section.start().Value();
+
+  StackFrameSymbolizer frame_symbolizer(&supplier, &resolver);
+  StackwalkerLOONGARCH64 walker(&system_info, &raw_context, &stack_region,
+                                &modules, &frame_symbolizer);
+  vector<const CodeModule*> modules_without_symbols;
+  vector<const CodeModule*> modules_with_corrupt_symbols;
+  ASSERT_TRUE(walker.Walk(&call_stack, &modules_without_symbols,
+                          &modules_with_corrupt_symbols));
+  ASSERT_EQ(2U, modules_without_symbols.size());
+  ASSERT_EQ("module1", modules_without_symbols[0]->debug_file());
+  ASSERT_EQ("module2", modules_without_symbols[1]->debug_file());
+  ASSERT_EQ(0U, modules_with_corrupt_symbols.size());
+  frames = call_stack.frames();
+  ASSERT_EQ(2U, frames->size());
+
+  StackFrameLOONGARCH64* frame0 =
+      static_cast<StackFrameLOONGARCH64*>(frames->at(0));
+  EXPECT_EQ(StackFrame::FRAME_TRUST_CONTEXT, frame0->trust);
+  ASSERT_EQ(StackFrameLOONGARCH64::CONTEXT_VALID_ALL, frame0->context_validity);
+  EXPECT_EQ(0, memcmp(&raw_context, &frame0->context, sizeof(raw_context)));
+
+  StackFrameLOONGARCH64* frame1 =
+      static_cast<StackFrameLOONGARCH64*>(frames->at(1));
+  EXPECT_EQ(StackFrame::FRAME_TRUST_SCAN, frame1->trust);
+  ASSERT_EQ((StackFrameLOONGARCH64::CONTEXT_VALID_PC |
+             StackFrameLOONGARCH64::CONTEXT_VALID_SP |
+             StackFrameLOONGARCH64::CONTEXT_VALID_FP |
+             StackFrameLOONGARCH64::CONTEXT_VALID_RA),
+            frame1->context_validity);
+  EXPECT_EQ(return_address1 - sizeof(return_address1), frame1->context.csr_era);
+  EXPECT_EQ(frame1_sp.Value(),
+            frame1->context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP]);
+}
+
+// Test that set_max_frames_scanned prevents using stack scanning
+// to find caller frames.
+TEST_F(GetCallerFrame, ScanningNotAllowed) {
+  // When the stack walker resorts to scanning the stack,
+  // only addresses located within loaded modules are
+  // considered valid return addresses.
+  stack_section.start() = 0x80000000;
+  uint64_t return_address1 = 0x50000100;
+  uint64_t return_address2 = 0x50000900;
+  Label frame1_sp, frame2_sp;
+  stack_section
+      // frame 0
+      .Append(32, 0)  // space
+
+      .D64(0x40090000)  // junk that's not
+      .D64(0x60000000)  // a return address
+
+      .D64(return_address1)  // actual return address
+      // frame 1
+      .Mark(&frame1_sp)
+      .Append(16, 0)  // space
+
+      .D64(0xF0000000)  // more junk
+      .D64(0x0000000D)
+
+      .D64(return_address2)  // actual return address
+      // frame 2
+      .Mark(&frame2_sp)
+      .Append(64, 0);  // end of stack
+  RegionFromSection();
+
+  raw_context.csr_era = 0x40005510;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP] =
+      stack_section.start().Value();
+
+  StackFrameSymbolizer frame_symbolizer(&supplier, &resolver);
+  StackwalkerLOONGARCH64 walker(&system_info, &raw_context, &stack_region,
+                                &modules, &frame_symbolizer);
+  Stackwalker::set_max_frames_scanned(0);
+
+  vector<const CodeModule*> modules_without_symbols;
+  vector<const CodeModule*> modules_with_corrupt_symbols;
+  ASSERT_TRUE(walker.Walk(&call_stack, &modules_without_symbols,
+                          &modules_with_corrupt_symbols));
+  ASSERT_EQ(1U, modules_without_symbols.size());
+  ASSERT_EQ("module1", modules_without_symbols[0]->debug_file());
+  ASSERT_EQ(0U, modules_with_corrupt_symbols.size());
+  frames = call_stack.frames();
+  ASSERT_EQ(1U, frames->size());
+
+  StackFrameLOONGARCH64* frame0 =
+      static_cast<StackFrameLOONGARCH64*>(frames->at(0));
+  EXPECT_EQ(StackFrame::FRAME_TRUST_CONTEXT, frame0->trust);
+  ASSERT_EQ(StackFrameLOONGARCH64::CONTEXT_VALID_ALL, frame0->context_validity);
+  EXPECT_EQ(0, memcmp(&raw_context, &frame0->context, sizeof(raw_context)));
+}
+
+struct CFIFixture : public StackwalkerLOONGARCH64Fixture {
+  CFIFixture() {
+    // Provide a bunch of STACK CFI records; we'll walk to the caller
+    // from every point in this series, expecting to find the same set
+    // of register values.
+    SetModuleSymbols(&module1,
+                     // The youngest frame's function.
+                     "FUNC 4000 1000 10 enchiridion\n"
+                     // Initially, nothing has been pushed on the stack,
+                     // and the return address is still in the return
+                     // address register (ra).
+                     "STACK CFI INIT 4000 100 .cfa: $sp 0 + .ra: $ra\n"
+                     // Push s1, s2, the frame pointer (fp) and the
+                     // return address register.
+                     "STACK CFI 4001 .cfa: $sp 32 + .ra: .cfa -8 + ^"
+                     " $s1: .cfa -32 + ^ $s2: .cfa -24 + ^ "
+                     " $fp: .cfa -16 + ^\n"
+                     // Save s1..s4 in a1..a4: verify that we populate
+                     // the youngest frame with all the values we have.
+                     "STACK CFI 4002 $s1: $a1 $s2: $a2 $s3: $a3 $s4: $a4\n"
+                     // Restore s1..s4. Save the non-callee-saves register a2.
+                     "STACK CFI 4003 .cfa: $sp 40 + $a2: .cfa 40 - ^"
+                     " $s1: $s1 $s2: $s2 $s3: $s3 $s4: $s4\n"
+                     // Move the .cfa back eight bytes, to point at the return
+                     // address, and restore the sp explicitly.
+                     "STACK CFI 4005 .cfa: $sp 32 + $a2: .cfa 32 - ^"
+                     " $fp: .cfa 8 - ^ .ra: .cfa ^ $sp: .cfa 8 +\n"
+                     // Recover the PC explicitly from a new stack slot;
+                     // provide garbage for the .ra.
+                     "STACK CFI 4006 .cfa: $sp 40 + .ra: .cfa 40 - ^\n"
+
+                     // The calling function.
+                     "FUNC 5000 1000 10 epictetus\n"
+                     // Mark it as end of stack.
+                     "STACK CFI INIT 5000 8 .cfa: $sp 0 + .ra: $ra\n"
+
+                     // A function whose CFI makes the stack pointer
+                     // go backwards.
+                     "FUNC 6000 1000 20 palinal\n"
+                     "STACK CFI INIT 6000 1000 .cfa: $sp 8 - .ra: $ra\n"
+
+                     // A function with CFI expressions that can't be
+                     // evaluated.
+                     "FUNC 7000 1000 20 rhetorical\n"
+                     "STACK CFI INIT 7000 1000 .cfa: moot .ra: ambiguous\n");
+
+    // Provide some distinctive values for the caller's registers.
+    expected.csr_era = 0x0000000040005510L;
+    expected.iregs[MD_CONTEXT_LOONGARCH64_REG_RA] = 0x0000000040005510L;
+    expected.iregs[MD_CONTEXT_LOONGARCH64_REG_SP] = 0x0000000080000000L;
+    expected.iregs[MD_CONTEXT_LOONGARCH64_REG_FP] = 0xe11081128112e110L;
+    expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S0] = 0x21f0ab46ab4621f0L;
+    expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S1] = 0x5e68b5d5b5d55e68L;
+    expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S2] = 0x34f3ebd1ebd134f3L;
+    expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S3] = 0x74bca31ea31e74bcL;
+    expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S4] = 0x16b32dcb2dcb16b3L;
+    expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S5] = 0x21372ada2ada2137L;
+    expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S6] = 0x557dbbbbbbbb557dL;
+    expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S7] = 0x8ca748bf48bf8ca7L;
+
+    // Expect CFI to recover all callee-saves registers. Since CFI is the
+    // only stack frame construction technique we have, aside from the
+    // context frame itself, there's no way for us to have a set of valid
+    // registers smaller than this.
+    expected_validity = (StackFrameLOONGARCH64::CONTEXT_VALID_PC |
+                         StackFrameLOONGARCH64::CONTEXT_VALID_SP |
+                         StackFrameLOONGARCH64::CONTEXT_VALID_RA |
+                         StackFrameLOONGARCH64::CONTEXT_VALID_FP |
+                         StackFrameLOONGARCH64::CONTEXT_VALID_S0 |
+                         StackFrameLOONGARCH64::CONTEXT_VALID_S1 |
+                         StackFrameLOONGARCH64::CONTEXT_VALID_S2 |
+                         StackFrameLOONGARCH64::CONTEXT_VALID_S3 |
+                         StackFrameLOONGARCH64::CONTEXT_VALID_S4 |
+                         StackFrameLOONGARCH64::CONTEXT_VALID_S5 |
+                         StackFrameLOONGARCH64::CONTEXT_VALID_S6 |
+                         StackFrameLOONGARCH64::CONTEXT_VALID_S7 |
+                         StackFrameLOONGARCH64::CONTEXT_VALID_S8);
+
+    // By default, context frames provide all registers, as normal.
+    context_frame_validity = StackFrameLOONGARCH64::CONTEXT_VALID_ALL;
+
+    // By default, registers are unchanged.
+    raw_context = expected;
+  }
+
+  // Walk the stack, using stack_section as the contents of the stack
+  // and raw_context as the current register values. (Set the stack
+  // pointer to the stack's starting address.) Expect two stack
+  // frames; in the older frame, expect the callee-saves registers to
+  // have values matching those in 'expected'.
+  void CheckWalk() {
+    RegionFromSection();
+    raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP] =
+        stack_section.start().Value();
+
+    StackFrameSymbolizer frame_symbolizer(&supplier, &resolver);
+    StackwalkerLOONGARCH64 walker(&system_info, &raw_context, &stack_region,
+                                  &modules, &frame_symbolizer);
+    vector<const CodeModule*> modules_without_symbols;
+    vector<const CodeModule*> modules_with_corrupt_symbols;
+    ASSERT_TRUE(walker.Walk(&call_stack, &modules_without_symbols,
+                            &modules_with_corrupt_symbols));
+    ASSERT_EQ(0U, modules_without_symbols.size());
+    ASSERT_EQ(0U, modules_with_corrupt_symbols.size());
+    frames = call_stack.frames();
+    ASSERT_EQ(2U, frames->size());
+
+    StackFrameLOONGARCH64* frame0 =
+        static_cast<StackFrameLOONGARCH64*>(frames->at(0));
+    EXPECT_EQ(StackFrame::FRAME_TRUST_CONTEXT, frame0->trust);
+    ASSERT_EQ(StackFrameLOONGARCH64::CONTEXT_VALID_ALL,
+              frame0->context_validity);
+    EXPECT_EQ("enchiridion", frame0->function_name);
+    EXPECT_EQ(0x0000000040004000UL, frame0->function_base);
+
+    StackFrameLOONGARCH64* frame1 =
+        static_cast<StackFrameLOONGARCH64*>(frames->at(1));
+    EXPECT_EQ(StackFrame::FRAME_TRUST_CFI, frame1->trust);
+    ASSERT_EQ(expected_validity, frame1->context_validity);
+    EXPECT_EQ(expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S0],
+              frame1->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S0]);
+    EXPECT_EQ(expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S1],
+              frame1->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S1]);
+    EXPECT_EQ(expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S2],
+              frame1->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S2]);
+    EXPECT_EQ(expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S3],
+              frame1->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S3]);
+    EXPECT_EQ(expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S4],
+              frame1->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S4]);
+    EXPECT_EQ(expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S5],
+              frame1->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S5]);
+    EXPECT_EQ(expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S6],
+              frame1->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S6]);
+    EXPECT_EQ(expected.iregs[MD_CONTEXT_LOONGARCH64_REG_S7],
+              frame1->context.iregs[MD_CONTEXT_LOONGARCH64_REG_S7]);
+    EXPECT_EQ(expected.iregs[MD_CONTEXT_LOONGARCH64_REG_SP],
+              frame1->context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP]);
+    EXPECT_EQ(expected.iregs[MD_CONTEXT_LOONGARCH64_REG_FP],
+              frame1->context.iregs[MD_CONTEXT_LOONGARCH64_REG_FP]);
+    EXPECT_EQ(expected.csr_era, frame1->context.csr_era);
+    EXPECT_EQ(expected.csr_era, frame1->instruction);
+    EXPECT_EQ("epictetus", frame1->function_name);
+  }
+  // The values we expect to find for the caller's registers.
+  MDRawContextLOONGARCH64 expected;
+
+  // The validity mask for expected.
+  long expected_validity;
+
+  // The validity mask to impose on the context frame.
+  long context_frame_validity;
+};
+
+class CFI : public CFIFixture, public Test {};
+
+TEST_F(CFI, At4000) {
+  stack_section.start() = expected.iregs[MD_CONTEXT_LOONGARCH64_REG_SP];
+  raw_context.csr_era = 0x0000000040004000L;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_RA] = 0x0000000040005510L;
+  CheckWalk();
+}
+
+TEST_F(CFI, At4001) {
+  Label frame1_sp = expected.iregs[MD_CONTEXT_LOONGARCH64_REG_SP];
+  stack_section
+      .D64(0x5e68b5d5b5d55e68L)  // saved s1
+      .D64(0x34f3ebd1ebd134f3L)  // saved s2
+      .D64(0xe11081128112e110L)  // saved fp
+      .D64(0x0000000040005510L)  // return address
+      .Mark(&frame1_sp);         // This effectively sets stack_section.start().
+  raw_context.csr_era = 0x0000000040004001L;
+  // distinct callee s1, s2 and fp
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_S1] = 0xadc9f635a635adc9L;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_S2] = 0x623135ac35ac6231L;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_FP] = 0x5fc4be14be145fc4L;
+  CheckWalk();
+}
+
+// As above, but unwind from a context that has only the PC and SP.
+TEST_F(CFI, At4001LimitedValidity) {
+  Label frame1_sp = expected.iregs[MD_CONTEXT_LOONGARCH64_REG_SP];
+  stack_section
+      .D64(0x5e68b5d5b5d55e68L)  // saved s1
+      .D64(0x34f3ebd1ebd134f3L)  // saved s2
+      .D64(0xe11081128112e110L)  // saved fp
+      .D64(0x0000000040005510L)  // return address
+      .Mark(&frame1_sp);         // This effectively sets stack_section.start().
+  context_frame_validity = StackFrameLOONGARCH64::CONTEXT_VALID_PC |
+                           StackFrameLOONGARCH64::CONTEXT_VALID_SP;
+  raw_context.csr_era = 0x0000000040004001L;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_FP] = 0x5fc4be14be145fc4L;
+
+  expected_validity |= (StackFrameLOONGARCH64::CONTEXT_VALID_PC |
+                        StackFrameLOONGARCH64::CONTEXT_VALID_SP |
+                        StackFrameLOONGARCH64::CONTEXT_VALID_FP |
+                        StackFrameLOONGARCH64::CONTEXT_VALID_S1 |
+                        StackFrameLOONGARCH64::CONTEXT_VALID_S2);
+  CheckWalk();
+}
+
+TEST_F(CFI, At4002) {
+  Label frame1_sp = expected.iregs[MD_CONTEXT_LOONGARCH64_REG_SP];
+  stack_section
+      .D64(0xff3dfb81fb81ff3dL)  // no longer saved s1
+      .D64(0x34f3ebd1ebd134f3L)  // no longer saved s2
+      .D64(0xe11081128112e110L)  // saved fp
+      .D64(0x0000000040005510L)  // return address
+      .Mark(&frame1_sp);         // This effectively sets stack_section.start().
+  raw_context.csr_era = 0x0000000040004002L;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_A1] =
+      0x5e68b5d5b5d55e68L;  // saved s1
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_A2] =
+      0x34f3ebd1ebd134f3L;  // saved s2
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_A3] =
+      0x74bca31ea31e74bcL;  // saved s3
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_A4] =
+      0x16b32dcb2dcb16b3L;  // saved s4
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_S1] =
+      0xadc9f635a635adc9L;  // distinct callee s1
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_S2] =
+      0x623135ac35ac6231L;  // distinct callee s2
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_S3] =
+      0xac4543564356ac45L;  // distinct callee s3
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_S4] =
+      0x2561562f562f2561L;  // distinct callee s4
+  // distinct callee fp
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_FP] = 0x5fc4be14be145fc4L;
+  CheckWalk();
+}
+
+TEST_F(CFI, At4003) {
+  Label frame1_sp = expected.iregs[MD_CONTEXT_LOONGARCH64_REG_SP];
+  stack_section
+      .D64(0xdd5a48c848c8dd5aL)  // saved a2 (even though it's not callee-saves)
+      .D64(0xff3dfb81fb81ff3dL)  // no longer saved s1
+      .D64(0x34f3ebd1ebd134f3L)  // no longer saved s2
+      .D64(0xe11081128112e110L)  // saved fp
+      .D64(0x0000000040005510L)  // return address
+      .Mark(&frame1_sp);         // This effectively sets stack_section.start().
+  raw_context.csr_era = 0x0000000040004003L;
+  // distinct callee a2 and fp
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_A2] = 0xfb756319fb756319L;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_FP] = 0x5fc4be14be145fc4L;
+  // caller's a2
+  expected.iregs[MD_CONTEXT_LOONGARCH64_REG_A2] = 0xdd5a48c848c8dd5aL;
+  expected_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_A2;
+  CheckWalk();
+}
+
+// We have no new rule at module offset 0x4004, so the results here should
+// be the same as those at module offset 0x4003.
+TEST_F(CFI, At4004) {
+  Label frame1_sp = expected.iregs[MD_CONTEXT_LOONGARCH64_REG_SP];
+  stack_section
+      .D64(0xdd5a48c848c8dd5aL)  // saved a2 (even though it's not callee-saves)
+      .D64(0xff3dfb81fb81ff3dL)  // no longer saved s1
+      .D64(0x34f3ebd1ebd134f3L)  // no longer saved s2
+      .D64(0xe11081128112e110L)  // saved fp
+      .D64(0x0000000040005510L)  // return address
+      .Mark(&frame1_sp);         // This effectively sets stack_section.start().
+  raw_context.csr_era = 0x0000000040004004L;
+  // distinct callee a2 and fp
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_A2] = 0xfb756319fb756319L;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_FP] = 0x5fc4be14be145fc4L;
+  // caller's a2
+  expected.iregs[MD_CONTEXT_LOONGARCH64_REG_A2] = 0xdd5a48c848c8dd5aL;
+  expected_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_A2;
+  CheckWalk();
+}
+
+// Here we move the .cfa, but provide an explicit rule to recover the SP,
+// so again there should be no change in the registers recovered.
+TEST_F(CFI, At4005) {
+  Label frame1_sp = expected.iregs[MD_CONTEXT_LOONGARCH64_REG_SP];
+  stack_section
+      .D64(0xdd5a48c848c8dd5aL)  // saved a2 (even though it's not callee-saves)
+      .D64(0xff3dfb81fb81ff3dL)  // no longer saved s1
+      .D64(0x34f3ebd1ebd134f3L)  // no longer saved s2
+      .D64(0xe11081128112e110L)  // saved fp
+      .D64(0x0000000040005510L)  // return address
+      .Mark(&frame1_sp);         // This effectively sets stack_section.start().
+  raw_context.csr_era = 0x0000000040004005L;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_A2] =
+      0xfb756319fb756319L;  // distinct callee a2
+  expected.iregs[MD_CONTEXT_LOONGARCH64_REG_A2] =
+      0xdd5a48c848c8dd5aL;  // caller's a2
+  expected_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_A2;
+  CheckWalk();
+}
+
+// Here we provide an explicit rule for the PC, and have the saved .ra be
+// bogus.
+TEST_F(CFI, At4006) {
+  Label frame1_sp = expected.iregs[MD_CONTEXT_LOONGARCH64_REG_SP];
+  stack_section
+      .D64(0x0000000040005510L)  // saved pc
+      .D64(0xdd5a48c848c8dd5aL)  // saved a2 (even though it's not callee-saves)
+      .D64(0xff3dfb81fb81ff3dL)  // no longer saved s1
+      .D64(0x34f3ebd1ebd134f3L)  // no longer saved s2
+      .D64(0xe11081128112e110L)  // saved fp
+      .D64(0xf8d157835783f8d1L)  // .ra rule recovers this, which is garbage
+      .Mark(&frame1_sp);         // This effectively sets stack_section.start().
+  raw_context.csr_era = 0x0000000040004006L;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_A2] =
+      0xfb756319fb756319L;  // distinct callee a2
+  expected.iregs[MD_CONTEXT_LOONGARCH64_REG_A2] =
+      0xdd5a48c848c8dd5aL;  // caller's a2
+  expected_validity |= StackFrameLOONGARCH64::CONTEXT_VALID_A2;
+  CheckWalk();
+}
+
+// Check that we reject rules that would cause the stack pointer to
+// move in the wrong direction.
+TEST_F(CFI, RejectBackwards) {
+  raw_context.csr_era = 0x0000000040006000L;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP] = 0x0000000080000000L;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_RA] = 0x0000000040005510L;
+  StackFrameSymbolizer frame_symbolizer(&supplier, &resolver);
+  StackwalkerLOONGARCH64 walker(&system_info, &raw_context, &stack_region,
+                                &modules, &frame_symbolizer);
+  vector<const CodeModule*> modules_without_symbols;
+  vector<const CodeModule*> modules_with_corrupt_symbols;
+  ASSERT_TRUE(walker.Walk(&call_stack, &modules_without_symbols,
+                          &modules_with_corrupt_symbols));
+  ASSERT_EQ(0U, modules_without_symbols.size());
+  ASSERT_EQ(0U, modules_with_corrupt_symbols.size());
+  frames = call_stack.frames();
+  ASSERT_EQ(1U, frames->size());
+}
+
+// Check that we reject rules whose expressions' evaluation fails.
+TEST_F(CFI, RejectBadExpressions) {
+  raw_context.csr_era = 0x0000000040007000L;
+  raw_context.iregs[MD_CONTEXT_LOONGARCH64_REG_SP] = 0x0000000080000000L;
+  StackFrameSymbolizer frame_symbolizer(&supplier, &resolver);
+  StackwalkerLOONGARCH64 walker(&system_info, &raw_context, &stack_region,
+                                &modules, &frame_symbolizer);
+  vector<const CodeModule*> modules_without_symbols;
+  vector<const CodeModule*> modules_with_corrupt_symbols;
+  ASSERT_TRUE(walker.Walk(&call_stack, &modules_without_symbols,
+                          &modules_with_corrupt_symbols));
+  ASSERT_EQ(0U, modules_without_symbols.size());
+  ASSERT_EQ(0U, modules_with_corrupt_symbols.size());
+  frames = call_stack.frames();
+  ASSERT_EQ(1U, frames->size());
+}
diff --git a/src/processor/synth_minidump.h b/src/processor/synth_minidump.h
index a52be03bf2753f7852245dee5b126045b1274fb1..b80d50582327690617fc0a32b55af1fb2d1a6a40 100644
--- a/src/processor/synth_minidump.h
+++ b/src/processor/synth_minidump.h
@@ -228,6 +228,7 @@ class Context: public Section {
   Context(const Dump& dump, const MDRawContextX86& context);
   Context(const Dump& dump, const MDRawContextARM& context);
   Context(const Dump& dump, const MDRawContextMIPS& context);
+  Context(const Dump& dump, const MDRawContextLOONGARCH64& context);
   // Add an empty context to the dump.
   Context(const Dump& dump) : Section(dump) {}
   // Add constructors for other architectures here. Remember to byteswap.
diff --git a/src/third_party/curl/curlbuild.h b/src/third_party/curl/curlbuild.h
index 2fb1d02049a2109290fc2aaf15982da767fa6d3f..6d43f4c7b5b133353f6f8d469237d7718c58615b 100644
--- a/src/third_party/curl/curlbuild.h
+++ b/src/third_party/curl/curlbuild.h
@@ -154,10 +154,11 @@
 #endif
 
 /* The size of `long', as computed by sizeof. */
-#if defined(_M_X64) || (defined(__x86_64__) && !defined(__ILP32__)) ||      \
-    defined(__aarch64__) || (defined(__mips__) && _MIPS_SIM == _ABI64) ||   \
-    defined(__powerpc64__) || defined(__s390x__) || defined(__LP64__) ||    \
-    (defined(__riscv) && __riscv_xlen == 64)
+#if defined(_M_X64) || (defined(__x86_64__) && !defined(__ILP32__)) ||    \
+    defined(__aarch64__) || (defined(__mips__) && _MIPS_SIM == _ABI64) || \
+    defined(__powerpc64__) || defined(__s390x__) || defined(__LP64__) ||  \
+    (defined(__riscv) && __riscv_xlen == 64) ||                           \
+    (defined(__loongarch__) && __loongarch_grlen == 64)
 #define CURL_SIZEOF_LONG 8
 #else
 #define CURL_SIZEOF_LONG 4
diff --git a/src/tools/linux/md2core/minidump-2-core.cc b/src/tools/linux/md2core/minidump-2-core.cc
index f12f2841acb705480676c708b87b413cb8e73a12..31fe5c3c03987f1b80572cfa70671d64cd30f445 100644
--- a/src/tools/linux/md2core/minidump-2-core.cc
+++ b/src/tools/linux/md2core/minidump-2-core.cc
@@ -82,6 +82,8 @@
   #define ELF_ARCH  EM_AARCH64
 #elif defined(__riscv)
   #define ELF_ARCH  EM_RISCV
+#elif defined(__loongarch__)
+  #define ELF_ARCH  EM_LOONGARCH
 #endif
 
 #if defined(__arm__)
@@ -264,7 +266,8 @@ typedef struct prpsinfo {       /* Information about process                 */
   unsigned char  pr_zomb;       /* Zombie                                    */
   signed char    pr_nice;       /* Nice val                                  */
   unsigned long  pr_flag;       /* Flags                                     */
-#if defined(__x86_64__) || defined(__mips__) || defined(__riscv)
+#if defined(__x86_64__) || defined(__mips__) || defined(__riscv)  || \
+    defined(__loongarch__)
   uint32_t       pr_uid;        /* User ID                                   */
   uint32_t       pr_gid;        /* Group ID                                  */
 #else
@@ -324,6 +327,9 @@ struct CrashedProcess {
 #endif
 #if defined(__aarch64__)
     user_fpsimd_struct fpregs;
+#endif
+#if defined(__loongarch__)
+    user_fp_struct fpregs;
 #endif
     uintptr_t stack_addr;
     const uint8_t* stack;
@@ -603,6 +609,17 @@ ParseThreadRegisters(CrashedProcess::Thread* thread,
 #  error "Unexpected __riscv_flen"
 # endif
 }
+#elif defined(__loongarch__)
+static void ParseThreadRegisters(CrashedProcess::Thread* thread,
+                                 const MinidumpMemoryRange& range) {
+  const MDRawContextLOONGARCH64* rawregs =
+      range.GetData<MDRawContextLOONGARCH64>(0);
+
+  for (int i = 0; i < MD_CONTEXT_LOONGARCH64_GPR_COUNT; ++i)
+    thread->regs.regs[i] = rawregs->iregs[i];
+
+  thread->regs.csr_era = rawregs->csr_era;
+}
 #else
 #error "This code has not been ported to your platform yet"
 #endif
@@ -708,6 +725,12 @@ ParseSystemInfo(const Options& options, CrashedProcess* crashinfo,
 # else
 #  error "Unexpected __riscv_xlen"
 # endif
+#elif defined(__loongarch__)
+  if (sysinfo->processor_architecture != MD_CPU_ARCHITECTURE_LOONGARCH64) {
+    fprintf(stderr,
+            "This version of minidump-2-core only supports Loongarch64.\n");
+    exit(1);
+  }
 #else
 #error "This code has not been ported to your platform yet"
 #endif
