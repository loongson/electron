From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Mingtao Zhou <zhoumingtao@loongson.cn>
Date: Thu, 14 Dec 2023 06:38:14 +0000
Subject: fix loongarch64 build

add "$" before the register name

diff --git a/linux_syscall_support.h b/linux_syscall_support.h
index ffd6a703dec0762d3a48020ebe5a18e784d72986..c3c7647c5660ab746e01f53a1f84ecb634496057 100644
--- a/linux_syscall_support.h
+++ b/linux_syscall_support.h
@@ -3940,17 +3940,17 @@ struct kernel_statx {
      * So, we just have to redefine all of the _syscallX() macros.
      */
     #undef LSS_REG
-    #define LSS_REG(ar,a) register int64_t __r##ar __asm__("a"#ar) = (int64_t)a
+    #define LSS_REG(ar,a) register int64_t __r##ar __asm__("$a"#ar) = (int64_t)a
     /* syscall is like subroutine calls, all caller-saved registers may be
      * clobbered, we should add them to the |Clobbers| list.
      * a0 is not included because it's in the output list.
      */
-    #define LSS_SYSCALL_CLOBBERS "t0", "t1", "t2", "t3", "t4", "t5", "t6",    \
-                                 "t7", "t8", "memory"
+    #define LSS_SYSCALL_CLOBBERS "$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6",    \
+                                 "$t7", "$t8", "memory"
     #undef  LSS_BODY
     #define LSS_BODY(type,name,args...)                                       \
-          register int64_t __res_a0 __asm__("a0");                            \
-          register int64_t __a7 __asm__("a7") = __NR_##name;                  \
+          register int64_t __res_a0 __asm__("$a0");                            \
+          register int64_t __a7 __asm__("$a7") = __NR_##name;                  \
           int64_t __res;                                                      \
           __asm__ __volatile__ ("syscall 0x0\n"                               \
                                 : "=r"(__res_a0)                              \
@@ -4013,12 +4013,12 @@ struct kernel_statx {
                                    void *newtls, int *child_tidptr) {
       int64_t __res;
       {
-        register int64_t __res_a0 __asm__("a0");
-        register uint64_t __flags __asm__("a0") = flags;
-        register void *__stack __asm__("a1") = child_stack;
-        register void *__ptid  __asm__("a2") = parent_tidptr;
-        register void *__tls   __asm__("a3") = newtls;
-        register int  *__ctid  __asm__("a4") = child_tidptr;
+        register int64_t __res_a0 __asm__("$a0");
+        register uint64_t __flags __asm__("$a0") = flags;
+        register void *__stack __asm__("$a1") = child_stack;
+        register void *__ptid  __asm__("$a2") = parent_tidptr;
+        register void *__tls   __asm__("$a3") = newtls;
+        register int  *__ctid  __asm__("$a4") = child_tidptr;
         __asm__ __volatile__(/* Push "arg" and "fn" onto the stack that will be
                               * used by the child.
                               */
@@ -4056,7 +4056,7 @@ struct kernel_statx {
                              : "r"(fn), "r"(__stack), "r"(__flags), "r"(arg),
                                "r"(__ptid), "r"(__tls), "r"(__ctid),
                                "i"(__NR_clone), "i"(__NR_exit)
-                             : "a7", LSS_SYSCALL_CLOBBERS);
+                             : "$a7", LSS_SYSCALL_CLOBBERS);
       __res = __res_a0;
       }
       LSS_RETURN(int, __res);
