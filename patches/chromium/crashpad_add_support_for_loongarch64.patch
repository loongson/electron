From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Mingtao Zhou <zhoumingtao@loongson.cn>
Date: Mon, 18 Dec 2023 02:46:44 +0000
Subject: Crashpad add support for loongarch64

support ABI 2.0

diff --git a/third_party/crashpad/crashpad/BUILD.gn b/third_party/crashpad/crashpad/BUILD.gn
index a79f68df52b8305f810c997ee4b3ede44772f955..4cd315eb3698494474fa535c4d5cd074e6ce5b6e 100644
--- a/third_party/crashpad/crashpad/BUILD.gn
+++ b/third_party/crashpad/crashpad/BUILD.gn
@@ -67,6 +67,12 @@ if (crashpad_is_in_chromium || crashpad_is_in_fuchsia) {
         "$root_out_dir/crashpad_test_data",
       ]
     }
+
+    ldflags = [
+      "-lnss3",
+      "-L" + rebase_path(root_build_dir),
+      "-Wl,-rpath=\$ORIGIN",
+    ]
   }
 
   if (crashpad_is_in_fuchsia) {
diff --git a/third_party/crashpad/crashpad/client/crashpad_client_linux.cc b/third_party/crashpad/crashpad/client/crashpad_client_linux.cc
index 630c24f115c78fa4cfe92c18373fc7edeee2c2d4..eab6006c7c83ce14e325f6f8e0920e79e2a7a8ce 100644
--- a/third_party/crashpad/crashpad/client/crashpad_client_linux.cc
+++ b/third_party/crashpad/crashpad/client/crashpad_client_linux.cc
@@ -716,6 +716,10 @@ void CrashpadClient::DumpWithoutCrash(NativeCPUContext* context) {
   memset(context->uc_mcontext.__reserved,
          0,
          sizeof(context->uc_mcontext.__reserved));
+#elif defined(ARCH_CPU_LOONG64)
+  memset(context->ucontext.uc_mcontext.__extcontext,
+         0,
+         sizeof(struct sctx_info));
 #endif
 
   siginfo_t siginfo;
diff --git a/third_party/crashpad/crashpad/compat/linux/sys/ptrace.h b/third_party/crashpad/crashpad/compat/linux/sys/ptrace.h
index 604a46ab06ac1f07db1e00b006238726e8127aaf..068a7c97995609f56bf40b89ffd1b12b2a63a0cd 100644
--- a/third_party/crashpad/crashpad/compat/linux/sys/ptrace.h
+++ b/third_party/crashpad/crashpad/compat/linux/sys/ptrace.h
@@ -38,6 +38,10 @@ static constexpr __ptrace_request PTRACE_GET_THREAD_AREA =
 static constexpr __ptrace_request PTRACE_GET_THREAD_AREA_3264 =
     static_cast<__ptrace_request>(0xc4);
 #define PTRACE_GET_THREAD_AREA_3264 PTRACE_GET_THREAD_AREA_3264
+#elif defined(__loongarch_lp64)
+static constexpr __ptrace_request PTRACE_GET_THREAD_AREA =
+    static_cast<__ptrace_request>(25);
+#define PTRACE_GET_THREAD_AREA PTRACE_GET_THREAD_AREA
 #endif
 #endif  // !PTRACE_GET_THREAD_AREA && !PT_GET_THREAD_AREA && defined(__GLIBC__)
 
diff --git a/third_party/crashpad/crashpad/compat/non_win/winnt.h b/third_party/crashpad/crashpad/compat/non_win/winnt.h
index 5fd78b0d8e08ded2faa161a06f9113c126bd23c6..66ca6332744cd1bdb6a80d01e56470f13235201f 100644
--- a/third_party/crashpad/crashpad/compat/non_win/winnt.h
+++ b/third_party/crashpad/crashpad/compat/non_win/winnt.h
@@ -67,6 +67,7 @@
 #define PROCESSOR_ARCHITECTURE_NEUTRAL 11
 #define PROCESSOR_ARCHITECTURE_ARM64 12
 #define PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64 13
+#define PROCESSOR_ARCHITECTURE_LOONG64 14
 #define PROCESSOR_ARCHITECTURE_UNKNOWN 0xffff
 //! \}
 
diff --git a/third_party/crashpad/crashpad/handler/BUILD.gn b/third_party/crashpad/crashpad/handler/BUILD.gn
index 02bf11a6de0457ca931e523c9e5070aa31c83fd6..43eb9d518e4303b7345086797bf1718670fb22b5 100644
--- a/third_party/crashpad/crashpad/handler/BUILD.gn
+++ b/third_party/crashpad/crashpad/handler/BUILD.gn
@@ -166,6 +166,7 @@ if (!crashpad_is_ios) {
     sources = [ "main.cc" ]
 
     deps = [
+      "//crypto:platform",
       ":handler",
       "../build:default_exe_manifest_win",
       "../compat",
@@ -246,6 +247,12 @@ if (!crashpad_is_ios) {
       "../third_party/mini_chromium:base",
       "../tools:tool_support",
     ]
+
+    ldflags = [
+      "-lnss3",
+      "-L" + rebase_path(root_build_dir),
+      "-Wl,-rpath=\$ORIGIN",
+    ]
   }
 }
 
diff --git a/third_party/crashpad/crashpad/minidump/minidump_context.h b/third_party/crashpad/crashpad/minidump/minidump_context.h
index 30988d8cb6e904a177a85a674625dbf3163e5dfc..49f5c37c7cb82cc61727b23ffbe9cffd456a491a 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_context.h
+++ b/third_party/crashpad/crashpad/minidump/minidump_context.h
@@ -637,6 +637,56 @@ struct MinidumpContextMIPS64 {
   uint64_t fir;
 };
 
+//! \brief LOONG64-specifc flags for MinidumpContextLOONG64::context_flags.
+//! Based on minidump_cpu_loong64.h from breakpad
+enum MinidumpContextLOONG64Flags : uint32_t {
+  //! \brief Identifies the context structure as LOONG64.
+  kMinidumpContextLOONG64 = 0x00800000,
+
+  //! \brief Indicates the validity of integer registers.
+  //!
+  //! Registers `0`-`31`, `epc` are valid.
+  kMinidumpContextLOONG64Integer = kMinidumpContextLOONG64 | 0x00000002,
+
+  //! \brief Indicates the validity of floating point registers.
+  //!
+  //! Floating point registers `0`-`31`, `fpcsr` and `fir` are valid
+  kMinidumpContextLOONG64FloatingPoint = kMinidumpContextLOONG64 | 0x00000004,
+
+  //! \brief Indicates the validity of all registers.
+  kMinidumpContextLOONG64All = kMinidumpContextLOONG64Integer |
+                              kMinidumpContextLOONG64FloatingPoint,
+};
+
+//! \brief A LOONG64 CPU context (register state) carried in a minidump file.
+struct MinidumpContextLOONG64 {
+  uint64_t context_flags;
+
+  //! \brief General purpose registers.
+  uint64_t regs[32];
+
+  //! \brief csr_era registers.
+  uint64_t csr_era;
+
+  //! \brief FPU registers.
+  union {
+    struct {
+      float _fp_fregs;
+      uint32_t _fp_pad;
+    } fregs[32];
+    double dregs[32];
+  } fpregs;
+
+  //! \brief Floating-point status and control register.
+  uint64_t fcc;
+
+  //! \brief Floating-point control and status register.
+  uint32_t fcsr;
+
+  //! \brief padding
+  uint32_t _pad;
+};
+
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_H_
diff --git a/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc b/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
index 5f741ed741ec45545a9f797925771a39e55a323b..8286622cf6e5b199aedf2ae212a2ba1a0bfeddea 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
@@ -102,6 +102,13 @@ MinidumpContextWriter::CreateFromSnapshot(const CPUContext* context_snapshot) {
       break;
     }
 
+    case kCPUArchitectureLOONG64: {
+      context = std::make_unique<MinidumpContextLOONG64Writer>();
+      reinterpret_cast<MinidumpContextLOONG64Writer*>(context.get())
+          ->InitializeFromSnapshot(context_snapshot->loong64);
+      break;
+    }
+
     default: {
       LOG(ERROR) << "unknown context architecture "
                  << context_snapshot->architecture;
@@ -556,4 +563,43 @@ size_t MinidumpContextMIPS64Writer::ContextSize() const {
   return sizeof(context_);
 }
 
+MinidumpContextLOONG64Writer::MinidumpContextLOONG64Writer()
+    : MinidumpContextWriter(), context_() {
+  context_.context_flags = kMinidumpContextLOONG64;
+}
+
+MinidumpContextLOONG64Writer::~MinidumpContextLOONG64Writer() = default;
+
+void MinidumpContextLOONG64Writer::InitializeFromSnapshot(
+    const CPUContextLOONG64* context_snapshot) {
+  DCHECK_EQ(state(), kStateMutable);
+  DCHECK_EQ(context_.context_flags, kMinidumpContextLOONG64);
+
+  context_.context_flags = kMinidumpContextLOONG64All;
+
+  static_assert(sizeof(context_.regs) == sizeof(context_snapshot->regs),
+                "GPRs size mismatch");
+  memcpy(context_.regs, context_snapshot->regs, sizeof(context_.regs));
+  context_.csr_era = context_snapshot->csr_era;
+
+  static_assert(sizeof(context_.fpregs) == sizeof(context_snapshot->fpregs),
+                "FPRs size mismatch");
+  memcpy(context_.fpregs.dregs,
+         context_snapshot->fpregs.dregs,
+         sizeof(context_.fpregs.dregs));
+  context_.fcsr = context_snapshot->fcsr;
+  context_.fcc = context_snapshot->fcc;
+}
+
+bool MinidumpContextLOONG64Writer::WriteObject(
+    FileWriterInterface* file_writer) {
+  DCHECK_EQ(state(), kStateWritable);
+  return file_writer->Write(&context_, sizeof(context_));
+}
+
+size_t MinidumpContextLOONG64Writer::ContextSize() const {
+  DCHECK_GE(state(), kStateFrozen);
+  return sizeof(context_);
+}
+
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/minidump/minidump_context_writer.h b/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
index 6660be437c993be69206d05033411fb6a56df77b..3eb04283e130b178788134cb8c5466cbe2434560 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
+++ b/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
@@ -22,6 +22,15 @@
 #include "minidump/minidump_context.h"
 #include "minidump/minidump_writable.h"
 
+// A macro to disallow the copy constructor and operator= functions
+// This should be used in the private: declarations for a class
+#ifndef DISALLOW_COPY_AND_ASSIGN
+#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
+  TypeName(const TypeName&);               \
+  void operator=(const TypeName&)
+#endif  // DISALLOW_COPY_AND_ASSIGN
+
+
 namespace crashpad {
 
 struct CPUContext;
@@ -369,6 +378,46 @@ class MinidumpContextMIPS64Writer final : public MinidumpContextWriter {
   MinidumpContextMIPS64 context_;
 };
 
+//! \brief The writer for a MinidumpContextLOONG64 structure in a minidump file.
+class MinidumpContextLOONG64Writer final : public MinidumpContextWriter {
+ public:
+  MinidumpContextLOONG64Writer();
+  ~MinidumpContextLOONG64Writer() override;
+
+  //! \brief Initializes the MinidumpContextLOONGARCH based on \a context_snapshot.
+  //!
+  //! \param[in] context_snapshot The context snapshot to use as source data.
+  //!
+  //! \note Valid in #kStateMutable. No mutation of context() may be done before
+  //!     calling this method, and it is not normally necessary to alter
+  //!     context() after calling this method.
+  void InitializeFromSnapshot(const CPUContextLOONG64* context_snapshot);
+
+  //! \brief Returns a pointer to the context structure that this object will
+  //!     write.
+  //!
+  //! \attention This returns a non-`const` pointer to this objectâ€™s private
+  //!     data so that a caller can populate the context structure directly.
+  //!     This is done because providing setter interfaces to each field in the
+  //!     context structure would be unwieldy and cumbersome. Care must be taken
+  //!     to populate the context structure correctly. The context structure
+  //!     must only be modified while this object is in the #kStateMutable
+  //!     state.
+  MinidumpContextLOONG64* context() { return &context_; }
+
+ protected:
+  // MinidumpWritable:
+  bool WriteObject(FileWriterInterface* file_writer) override;
+
+  // MinidumpContextWriter:
+  size_t ContextSize() const override;
+
+ private:
+  MinidumpContextLOONG64 context_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpContextLOONG64Writer);
+};
+
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_WRITER_H_
diff --git a/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc b/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc
index e2a04d1dcf9e13a0e97d0d1fa6fda0d9c83569d1..a18e087331919f6260e24d7783b87518a357deca 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc
@@ -268,6 +268,23 @@ TYPED_TEST(MinidumpContextWriter, MIPS64_FromSnapshot) {
                    TypeParam>(context, ExpectMinidumpContextMIPS64, kSeed);
 }
 
+TYPED_TEST(MinidumpContextWriter, LOONG64_Zeros) {
+  EmptyContextTest<MinidumpContextLOONG64Writer,
+                   MinidumpContextLOONG64
+                   TypeParam>(ExpectMinidumpContextLOONG64);
+}
+
+TYPED_TEST(MinidumpContextWriter, LOONG64_FromSnapshot) {
+  constexpr uint32_t kSeed = 64;
+  CPUContextLOONG64 context_loong64;
+  CPUContext context;
+  context.loong64 = &context_loong64;
+  InitializeCPUContextLOONG64(&context, kSeed);
+  FromSnapshotTest<MinidumpContextLOONG64Writer,
+                   MinidumpContextLOONG64
+                   TypeParam>(context, ExpectMinidumpContextLOONG64, kSeed);
+}
+
 }  // namespace
 }  // namespace test
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/minidump/minidump_extensions.h b/third_party/crashpad/crashpad/minidump/minidump_extensions.h
index f96cf25b6a45a9ec22ecca6ecf82356ea444e90e..203793b54626a7691e633bfc6ee3fe001a60a6d8 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_extensions.h
+++ b/third_party/crashpad/crashpad/minidump/minidump_extensions.h
@@ -154,6 +154,7 @@ enum MinidumpCPUArchitecture : uint16_t {
   kMinidumpCPUArchitectureX86 = PROCESSOR_ARCHITECTURE_INTEL,
 
   kMinidumpCPUArchitectureMIPS = PROCESSOR_ARCHITECTURE_MIPS,
+  kMinidumpCPUArchitectureLOONG64 = PROCESSOR_ARCHITECTURE_LOONG64,
   kMinidumpCPUArchitectureAlpha = PROCESSOR_ARCHITECTURE_ALPHA,
 
   //! \brief 32-bit PowerPC.
diff --git a/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc b/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
index 133ae3086aa8756363bbb310c266964bbc47dd93..ef97dde6f890ff61811ab5b2a1d08b06bdf7715b 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
@@ -175,6 +175,8 @@ std::string MinidumpMiscInfoDebugBuildString() {
   static constexpr char kCPU[] = "mips";
 #elif defined(ARCH_CPU_MIPS64EL)
   static constexpr char kCPU[] = "mips64";
+#elif defined(ARCH_CPU_LOONG64)
+  static constexpr char kCPU[] = "loong64";
 #else
 #error define kCPU for this CPU
 #endif
diff --git a/third_party/crashpad/crashpad/minidump/minidump_system_info_writer.cc b/third_party/crashpad/crashpad/minidump/minidump_system_info_writer.cc
index 4468c41afff67bc90ee623190afc14290c2d2370..6cc9dcefc1c932368f99e4d64982aa8031207185 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_system_info_writer.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_system_info_writer.cc
@@ -132,6 +132,9 @@ void MinidumpSystemInfoWriter::InitializeFromSnapshot(
     case kCPUArchitectureARM64:
       cpu_architecture = kMinidumpCPUArchitectureARM64;
       break;
+    case kCPUArchitectureLOONG64:
+      cpu_architecture = kMinidumpCPUArchitectureLOONG64;
+      break;
     default:
       NOTREACHED();
       cpu_architecture = kMinidumpCPUArchitectureUnknown;
diff --git a/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.cc b/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.cc
index 5746e4c3016034e5745e756dbe004c95b3a26ac8..a88bc9a3715c6477cc0442e6877c6f09f597eba9 100644
--- a/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.cc
+++ b/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.cc
@@ -272,6 +272,31 @@ void InitializeMinidumpContextMIPS64(MinidumpContextMIPS64* context,
   context->dsp_control = value++;
 }
 
+void InitializeMinidumpContextLOONG64(MinidumpContextLOONG64* context,
+                                     uint32_t seed) {
+  if (seed == 0) {
+    memset(context, 0, sizeof(*context));
+    context->context_flags = kMinidumpContextLOONG64;
+    return;
+  }
+
+  context->context_flags = kMinidumpContextLOONG64All;
+
+  uint64_t value = seed;
+
+  for (size_t index = 0; index < std::size(context->regs); ++index) {
+    context->regs[index] = value++;
+  }
+
+  context->csr_era = value++;
+
+  for (size_t index = 0; index < std::size(context->fpregs.dregs); ++index) {
+    context->fpregs.dregs[index] = static_cast<double>(value++);
+  }
+  context->fcsr = value++;
+  context->fcc = value++;
+}
+
 namespace {
 
 // Using Google Test assertions, compares |expected| to |observed|. This is
@@ -601,5 +626,26 @@ void ExpectMinidumpContextMIPS64(uint32_t expect_seed,
   EXPECT_EQ(observed->dsp_control, expected.dsp_control);
 }
 
+void ExpectMinidumpContextLOONG64(uint32_t expect_seed,
+                                 const MinidumpContextLOONG64* observed,
+                                 bool snapshot) {
+  MinidumpContextLOONG64 expected;
+  InitializeMinidumpContextLOONG64(&expected, expect_seed);
+
+  EXPECT_EQ(observed->context_flags, expected.context_flags);
+
+  for (size_t index = 0; index < std::size(expected.regs); ++index) {
+    EXPECT_EQ(observed->regs[index], expected.regs[index]);
+  }
+
+  EXPECT_EQ(observed->csr_era, expected.csr_era);
+
+  for (size_t index = 0; index < std::size(expected.fpregs.dregs); ++index) {
+    EXPECT_EQ(observed->fpregs.dregs[index], expected.fpregs.dregs[index]);
+  }
+  EXPECT_EQ(observed->fcsr, expected.fcsr);
+  EXPECT_EQ(observed->fcc, expected.fcc);
+}
+
 }  // namespace test
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.h b/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.h
index 793e2c39c75cce6e05724595b914349cae5ff1f4..2e9ad8054174786d55880b13be01b36cb2dc4fb9 100644
--- a/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.h
+++ b/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.h
@@ -47,6 +47,8 @@ void InitializeMinidumpContextARM64(MinidumpContextARM64* context,
 void InitializeMinidumpContextMIPS(MinidumpContextMIPS* context, uint32_t seed);
 void InitializeMinidumpContextMIPS64(MinidumpContextMIPS* context,
                                      uint32_t seed);
+void InitializeMinidumpContextLOONG64(MinidumpContextLOONG64* context,
+                                     uint32_t seed);
 //! \}
 
 //! \brief Verifies, via Google Test assertions, that a context structure
@@ -85,6 +87,9 @@ void ExpectMinidumpContextMIPS(uint32_t expect_seed,
 void ExpectMinidumpContextMIPS64(uint32_t expect_seed,
                                  const MinidumpContextMIPS64* observed,
                                  bool snapshot);
+void ExpectMinidumpContextLOONG64(uint32_t expect_seed,
+                                 const MinidumpContextLOONG64* observed,
+                                 bool snapshot);
 //! \}
 
 }  // namespace test
diff --git a/third_party/crashpad/crashpad/snapshot/BUILD.gn b/third_party/crashpad/crashpad/snapshot/BUILD.gn
index 044f33db5b82c30daaacc020330c45df1a2ae4d2..c8621cef85e951694ae5d3a858431b43186d0697 100644
--- a/third_party/crashpad/crashpad/snapshot/BUILD.gn
+++ b/third_party/crashpad/crashpad/snapshot/BUILD.gn
@@ -468,7 +468,8 @@ source_set("snapshot_test") {
   }
 
   if ((crashpad_is_linux || crashpad_is_android || crashpad_is_fuchsia) &&
-      target_cpu != "mipsel" && target_cpu != "mips64el") {
+      target_cpu != "mipsel" && target_cpu != "mips64el" &&
+      target_cpu != "loong64") {
     data_deps += [ ":crashpad_snapshot_test_both_dt_hash_styles" ]
   }
 
@@ -506,6 +507,12 @@ crashpad_loadable_module("crashpad_snapshot_test_module") {
     "$mini_chromium_source_parent:base",
     "../client",
   ]
+
+  ldflags = [
+    "-lnss3",
+    "-L" + rebase_path(root_build_dir),
+    "-Wl,-rpath=\$ORIGIN",
+  ]
   if (crashpad_is_in_fuchsia) {
     # TODO(fxbug.dev/108368): Remove this once the underlying issue is addressed.
     exclude_toolchain_tags = [ "hwasan" ]
@@ -525,6 +532,11 @@ crashpad_loadable_module("crashpad_snapshot_test_module_large") {
   defines = [ "CRASHPAD_INFO_SIZE_TEST_MODULE_LARGE" ]
   deps += [ "$mini_chromium_source_parent:base" ]
 
+  ldflags = [
+    "-lnss3",
+    "-L" + rebase_path(root_build_dir),
+    "-Wl,-rpath=\$ORIGIN",
+  ]
   if (crashpad_is_in_fuchsia) {
     # TODO(fxbug.dev/108368): Remove this once the underlying issue is addressed.
     exclude_toolchain_tags = [ "hwasan" ]
@@ -544,6 +556,11 @@ crashpad_loadable_module("crashpad_snapshot_test_module_small") {
   defines = [ "CRASHPAD_INFO_SIZE_TEST_MODULE_SMALL" ]
   deps += [ "$mini_chromium_source_parent:base" ]
 
+  ldflags = [
+    "-lnss3",
+    "-L" + rebase_path(root_build_dir),
+    "-Wl,-rpath=\$ORIGIN",
+  ]
   if (crashpad_is_in_fuchsia) {
     # TODO(fxbug.dev/108368): Remove this once the underlying issue is addressed.
     exclude_toolchain_tags = [ "hwasan" ]
@@ -551,7 +568,8 @@ crashpad_loadable_module("crashpad_snapshot_test_module_small") {
 }
 
 if ((crashpad_is_linux || crashpad_is_android || crashpad_is_fuchsia) &&
-    target_cpu != "mipsel" && target_cpu != "mips64el") {
+    target_cpu != "mipsel" && target_cpu != "mips64el" &&
+    target_cpu != "loong64") {
   crashpad_loadable_module("crashpad_snapshot_test_both_dt_hash_styles") {
     testonly = true
     sources = [ "hash_types_test.cc" ]
diff --git a/third_party/crashpad/crashpad/snapshot/capture_memory.cc b/third_party/crashpad/crashpad/snapshot/capture_memory.cc
index 0a465d22f605b09a5503b5b810647c8742cae997..622c9de457e33287c6bf63b185832f2f15b1951d 100644
--- a/third_party/crashpad/crashpad/snapshot/capture_memory.cc
+++ b/third_party/crashpad/crashpad/snapshot/capture_memory.cc
@@ -117,6 +117,10 @@ void CaptureMemory::PointedToByContext(const CPUContext& context,
   for (size_t i = 0; i < std::size(context.mipsel->regs); ++i) {
     MaybeCaptureMemoryAround(delegate, context.mipsel->regs[i]);
   }
+#elif defined(ARCH_CPU_LOONG64)
+  for (size_t i = 0; i < std::size(context.loong64->regs); ++i) {
+    MaybeCaptureMemoryAround(delegate, context.loong64->regs[i]);
+  }
 #else
 #error Port.
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/cpu_architecture.h b/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
index 4003a9290f44d97c1c2e5e6f24176d63e833b72c..7201fd0b1c9ef6c869c75a9b6deb28e45909a3f7 100644
--- a/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
+++ b/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
@@ -43,7 +43,10 @@ enum CPUArchitecture {
   kCPUArchitectureMIPSEL,
 
   //! \brief 64-bit MIPSEL.
-  kCPUArchitectureMIPS64EL
+  kCPUArchitectureMIPS64EL,
+
+  //! \brief 64-bit LOONGARCH.
+  kCPUArchitectureLOONG64,
 };
 
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/snapshot/cpu_context.cc b/third_party/crashpad/crashpad/snapshot/cpu_context.cc
index 6eaa853fd57063f9a6aa1345e1c65168334aafd9..0f97ea357ebb004321e6a54a12087a95d0f47d2f 100644
--- a/third_party/crashpad/crashpad/snapshot/cpu_context.cc
+++ b/third_party/crashpad/crashpad/snapshot/cpu_context.cc
@@ -170,6 +170,8 @@ uint64_t CPUContext::InstructionPointer() const {
       return arm->pc;
     case kCPUArchitectureARM64:
       return arm64->pc;
+    case kCPUArchitectureLOONG64:
+      return loong64->csr_era;
     default:
       NOTREACHED();
       return ~0ull;
@@ -186,6 +188,8 @@ uint64_t CPUContext::StackPointer() const {
       return arm->sp;
     case kCPUArchitectureARM64:
       return arm64->sp;
+    case kCPUArchitectureLOONG64:
+      return loong64->regs[3];
     default:
       NOTREACHED();
       return ~0ull;
@@ -226,6 +230,7 @@ bool CPUContext::Is64Bit() const {
     case kCPUArchitectureX86_64:
     case kCPUArchitectureARM64:
     case kCPUArchitectureMIPS64EL:
+    case kCPUArchitectureLOONG64:
       return true;
     case kCPUArchitectureX86:
     case kCPUArchitectureARM:
diff --git a/third_party/crashpad/crashpad/snapshot/cpu_context.h b/third_party/crashpad/crashpad/snapshot/cpu_context.h
index 7bc252be15c70171e966a6c74de821fb301a917f..19a4458e1522623ecce88d79b20756d8d763004f 100644
--- a/third_party/crashpad/crashpad/snapshot/cpu_context.h
+++ b/third_party/crashpad/crashpad/snapshot/cpu_context.h
@@ -362,6 +362,22 @@ struct CPUContextMIPS64 {
   uint64_t fir;
 };
 
+//! \brief A context structure carrying LOONG64 CPU state.
+struct CPUContextLOONG64 {
+  uint64_t regs[32];
+  uint64_t csr_era;
+  union {
+    double dregs[32];
+    struct {
+      float _fp_fregs;
+      uint32_t _fp_pad;
+    } fregs[32];
+  } fpregs;
+  uint64_t fcc;
+  uint32_t fcsr;
+  uint32_t _pad;
+};
+
 //! \brief A context structure capable of carrying the context of any supported
 //!     CPU architecture.
 struct CPUContext {
@@ -402,6 +418,7 @@ struct CPUContext {
     CPUContextARM64* arm64;
     CPUContextMIPS* mipsel;
     CPUContextMIPS64* mips64;
+    CPUContextLOONG64* loong64;
   };
 };
 
diff --git a/third_party/crashpad/crashpad/snapshot/elf/elf_image_reader.cc b/third_party/crashpad/crashpad/snapshot/elf/elf_image_reader.cc
index 30e8b987c0754cef605ff892521388671f065671..d6bf94f155c8e60a7aa8109289713a88beb79878 100644
--- a/third_party/crashpad/crashpad/snapshot/elf/elf_image_reader.cc
+++ b/third_party/crashpad/crashpad/snapshot/elf/elf_image_reader.cc
@@ -754,6 +754,7 @@ bool ElfImageReader::GetNumberOfSymbolEntriesFromDtHash(
     return false;
   }
 
+
   struct {
     uint32_t nbucket;
     uint32_t nchain;
diff --git a/third_party/crashpad/crashpad/snapshot/elf/elf_symbol_table_reader.cc b/third_party/crashpad/crashpad/snapshot/elf/elf_symbol_table_reader.cc
index 4c59d74599498378785425ce15f9a32157bd1eb4..dad0120dde28024632e06aab0ebc260522eeaf8b 100644
--- a/third_party/crashpad/crashpad/snapshot/elf/elf_symbol_table_reader.cc
+++ b/third_party/crashpad/crashpad/snapshot/elf/elf_symbol_table_reader.cc
@@ -72,16 +72,21 @@ bool ElfSymbolTableReader::ScanSymbolTable(const std::string& name,
   SymEnt entry;
   std::string string;
   size_t i = 0;
+  const char vdso_prefix[] = "__vdso_";
+
   while (i < num_entries_ && memory_->Read(address, sizeof(entry), &entry)) {
-    if (elf_reader_->ReadDynamicStringTableAtOffset(entry.st_name, &string) &&
-        string == name) {
-      info_out->address = entry.st_value;
-      info_out->size = entry.st_size;
-      info_out->shndx = entry.st_shndx;
-      info_out->binding = GetBinding(entry);
-      info_out->type = GetType(entry);
-      info_out->visibility = GetVisibility(entry);
-      return true;
+    if (elf_reader_->ReadDynamicStringTableAtOffset(entry.st_name, &string)) {
+      if (string.find(vdso_prefix) == 0)
+        string.erase(0, sizeof(vdso_prefix) - 1);
+      if (string == name) {
+        info_out->address = entry.st_value;
+        info_out->size = entry.st_size;
+        info_out->shndx = entry.st_shndx;
+        info_out->binding = GetBinding(entry);
+        info_out->type = GetType(entry);
+        info_out->visibility = GetVisibility(entry);
+        return true;
+      }
     }
     // TODO(scottmg): This should respect DT_SYMENT if present.
     address += sizeof(entry);
diff --git a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc
index 21db2343240f7e57fdecd07740b7d908c3d6e332..ee4e05012d96f185e597ccf8c49a12ae79f08f6e 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc
@@ -266,6 +266,40 @@ void InitializeCPUContextARM64_OnlyFPSIMD(
   context->fpcr = float_context.fpcr;
 }
 
+#elif defined(ARCH_CPU_LOONG64)
+
+void InitializeCPUContextLOONG64_NoFloatingPoint(
+    const ThreadContext::t64_t& thread_context,
+    CPUContextLOONG64* context) {
+  static_assert(sizeof(context->regs) == sizeof(thread_context.regs),
+                "gpr context size mismtach");
+  memcpy(context->regs, thread_context.regs, sizeof(context->regs));
+  context->csr_era = thread_context.csr_era;
+
+  memset(&context->fpregs, 0, sizeof(context->fpregs));
+  context->fcc = 0;
+  context->fcsr = 0;
+}
+
+void InitializeCPUContextLOONG64_OnlyFPU(
+    const FloatContext::f64_t& float_context,
+    CPUContextLOONG64* context) {
+  static_assert(sizeof(context->fpregs) == sizeof(float_context.fpregs),
+                "fpu context size mismatch");
+  memcpy(&context->fpregs, &float_context.fpregs, sizeof(context->fpregs));
+  context->fcc = float_context.fcc;
+  context->fcsr = float_context.fcsr;
+}
+
+void InitializeCPUContextLOONG64(
+    const ThreadContext::t64_t& thread_context,
+    const FloatContext::f64_t& float_context,
+    CPUContextLOONG64* context) {
+  InitializeCPUContextLOONG64_NoFloatingPoint(thread_context, context);
+
+  InitializeCPUContextLOONG64_OnlyFPU(float_context, context);
+}
+
 #endif  // ARCH_CPU_X86_FAMILY
 
 }  // namespace internal
diff --git a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
index 1ea5eecda686d236d5869b159ec14a997b175933..a47d41935ad9e232e58242a94ef0106bf83daf81 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
@@ -174,6 +174,44 @@ void InitializeCPUContextMIPS(
 
 #endif  // ARCH_CPU_MIPS_FAMILY || DOXYGEN
 
+#if defined(ARCH_CPU_LOONG64) || DOXYGEN
+
+//! \brief Initializes GPR state in a CPUContextLOONG64 from a native context
+//!     structure on Linux.
+//!
+//! Floating point state is initialized to zero.
+//!
+//! \param[in] thread_context The native thread context.
+//! \param[out] context The CPUContextLOONG64 structure to initialize.
+void InitializeCPUContextLOONG64_NoFloatingPoint(
+    const ThreadContext::t64_t& thread_context,
+    CPUContextLOONG64* context);
+//! \brief Initializes FPU state in a CPUContextLOONG64 from a native fpu
+//!     signal context structure on Linux.
+//!
+//! General purpose registers are not initialized.
+//!
+//! \param[in] float_context The native fpu context.
+//! \param[out] context The CPUContextLOONG64 structure to initialize.
+void InitializeCPUContextLOONG64_OnlyFPU(
+    const FloatContext::f64_t& float_context,
+    CPUContextLOONG64* context);
+//! \brief Initializes a CPUContextLOONG64 structure from native context
+//!     structures on Linux.
+//!
+//! This function has template specializations for LOONG64 architecture
+//! contexts, using ContextTraits32 or ContextTraits64 as template parameter,
+//! respectively.
+//!
+//! \param[in] thread_context The native thread context.
+//! \param[in] float_context The native float context.
+//! \param[out] context The CPUContextLOONG64 structure to initialize.
+void InitializeCPUContextLOONG64(
+    const ThreadContext::t64_t& thread_context,
+    const FloatContext::f64_t& float_context,
+    CPUContextLOONG64* context);
+#endif  // ARCH_CPU_LOONG64 || DOXYGEN
+
 }  // namespace internal
 }  // namespace crashpad
 
diff --git a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
index 4e6ec11f8bd28fa4058cda257abd4bc92feb634e..79eb839c8eb825c0d4916706b86b69ac4d0b6284 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
@@ -15,6 +15,7 @@
 #include "snapshot/linux/exception_snapshot_linux.h"
 
 #include <signal.h>
+#include <string.h>
 
 #include "base/logging.h"
 #include "snapshot/linux/capture_memory_delegate_linux.h"
@@ -325,6 +326,79 @@ bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
       reader, context_address, context_.mips64);
 }
 
+#elif defined(ARCH_CPU_LOONG64)
+
+template <typename Traits>
+static bool ReadContext(ProcessReaderLinux* reader,
+                        LinuxVMAddress context_address,
+                        typename Traits::CPUContext* dest_context) {
+  const ProcessMemory* memory = reader->Memory();
+  LinuxVMAddress gregs_address = context_address +
+                                 offsetof(UContext<Traits>, mcontext);
+  ThreadContext::t64_t thread_context;
+  typename Traits::MContext mcontext;
+  if (!memory->Read(gregs_address, sizeof(mcontext), &mcontext)) {
+    LOG(ERROR) << "Couldn't read gregs";
+    return false;
+  }
+  static_assert(sizeof(thread_context.regs) == sizeof(mcontext.gregs),
+                "gpr context size mismtach");
+  memcpy(thread_context.regs, mcontext.gregs, sizeof(mcontext.gregs));
+  thread_context.csr_era = mcontext.pc;
+  thread_context.orig_a0 = 0;
+  thread_context.csr_badv = 0;
+  InitializeCPUContextLOONG64_NoFloatingPoint(thread_context, dest_context);
+  LinuxVMAddress reserved_address =
+        context_address + offsetof(UContext<Traits>, mcontext.extcontext);
+  if ((reserved_address & 15) != 0) {
+    LOG(ERROR) << "invalid alignment 0x" << std::hex << reserved_address;
+    return false;
+   }
+  constexpr VMSize kMaxContextSpace = 4096;
+  ProcessMemoryRange range;
+  if (!range.Initialize(memory, true, reserved_address, kMaxContextSpace)) {
+    return false;
+  }
+  do {
+    struct sctx_info head;
+    if (!range.Read(reserved_address, sizeof(head), &head)) {
+      LOG(ERROR) << "missing context terminator";
+      return false;
+    }
+    reserved_address += sizeof(head);
+    switch (head.magic) {
+      case FPU_CTX_MAGIC:
+        if (head.size != sizeof(struct fpu_context) + sizeof(head)) {
+          LOG(ERROR) << "unexpected fpu context size " << head.size;
+          return false;
+        }
+        FloatContext::f64_t fpucontext;
+        if (!range.Read(reserved_address, sizeof(fpucontext), &fpucontext)) {
+          LOG(ERROR) << "Couldn't read fpu " << head.size;
+          return false;
+        }
+        InitializeCPUContextLOONG64_OnlyFPU(fpucontext, dest_context);
+        return true;
+      case 0:
+        return true;
+      default:
+        LOG(ERROR) << "invalid magic number 0x" << std::hex << head.magic;
+        return false;
+    }
+  } while (true);
+}
+
+template <>
+bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
+    ProcessReaderLinux* reader,
+    LinuxVMAddress context_address) {
+  context_.architecture = kCPUArchitectureLOONG64;
+  context_.loong64 = &context_union_.loong64;
+
+  return internal::ReadContext<ContextTraits64>(
+      reader, context_address, context_.loong64);
+}
+
 #endif  // ARCH_CPU_X86_FAMILY
 
 bool ExceptionSnapshotLinux::Initialize(
@@ -354,12 +428,15 @@ bool ExceptionSnapshotLinux::Initialize(
         !ReadSiginfo<Traits64>(process_reader, siginfo_address)) {
       return false;
     }
-  } else {
+  }
+#if !defined(ARCH_CPU_LOONG64)
+  else {
     if (!ReadContext<ContextTraits32>(process_reader, context_address) ||
         !ReadSiginfo<Traits32>(process_reader, siginfo_address)) {
       return false;
     }
   }
+#endif
 
   CaptureMemoryDelegateLinux capture_memory_delegate(
       process_reader,
diff --git a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
index 3ea3d931fe0afd1903f4769e290b34255aae0dca..cbaad2ac7dee27c345dd7a7a542a4d6fea0ef871 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
@@ -89,6 +89,8 @@ class ExceptionSnapshotLinux final : public ExceptionSnapshot {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
     CPUContextMIPS mipsel;
     CPUContextMIPS64 mips64;
+#elif defined(ARCH_CPU_LOONG64)
+    CPUContextLOONG64 loong64;
 #endif
   } context_union_;
   CPUContext context_;
diff --git a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
index b0c75b98a066647f57a04e1bb039198e17654439..0e9e9c529bc29d3adc70050cf1a506b1cf7b9982 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
@@ -297,6 +297,25 @@ void ExpectContext(const CPUContext& actual, const NativeCPUContext& expected) {
             0);
 #undef CPU_ARCH_NAME
 }
+#elif defined(ARCH_CPU_LOONG64)
+struct NativeCPUContext {
+  ucontext_t ucontext;
+  struct sctx_info info;
+};
+void InitializeContext(NativeCPUContext* context) {
+  for (size_t reg = 0; reg < std::size(context->ucontext.uc_mcontext.__gregs); ++reg) {
+    context->ucontext.uc_mcontext.__gregs[reg] = reg;
+  }
+  context->info.magic = 0;
+  context->info.size = 0;
+}
+void ExpectContext(const CPUContext& actual, const NativeCPUContext& expected) {
+  EXPECT_EQ(actual.architecture, kCPUArchitectureLOONG64);
+  for (size_t reg = 0; reg < std::size(expected.ucontext.uc_mcontext.__gregs); ++reg) {
+    EXPECT_EQ(actual.loongarch64->regs[reg], expected.ucontext.uc_mcontext.__gregs[reg]);
+  }
+}
+
 
 #else
 #error Port.
diff --git a/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
index 8ec0edc6dab0c343c4621bd9f2b10295ba2de910..855eeeead02833fba8f8c10b38f9baccee9bc075 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
@@ -127,6 +127,8 @@ void ProcessReaderLinux::Thread::InitializeStack(ProcessReaderLinux* reader) {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   stack_pointer = reader->Is64Bit() ? thread_info.thread_context.t64.regs[29]
                                     : thread_info.thread_context.t32.regs[29];
+#elif defined(ARCH_CPU_LOONG64)
+  stack_pointer = thread_info.thread_context.t64.regs[3];
 #else
 #error Port.
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/linux/signal_context.h b/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
index 6ac7adea4780a0a9899eb73e6ee1d4750b4527f2..68d04947755fbd1b2244d818db107d4262d0c150 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
@@ -41,7 +41,7 @@ union Sigval {
 template <class Traits>
 struct Siginfo {
   int32_t signo;
-#ifdef ARCH_CPU_MIPS_FAMILY
+#if defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONG64_FAMILY)
   // Attribute order for signo_t defined in kernel is different for MIPS.
   int32_t code;
   int32_t err;
@@ -420,7 +420,45 @@ static_assert(offsetof(UContext<ContextTraits64>, mcontext.gregs) ==
 static_assert(offsetof(UContext<ContextTraits64>, mcontext.fpregs) ==
                   offsetof(ucontext_t, uc_mcontext.fpregs),
               "context offset mismatch");
-#endif
+#endif // ARCH_CPU_MIPSEL
+
+#elif defined(ARCH_CPU_LOONG64)
+
+struct MContext64 {
+  uint64_t pc;
+  uint64_t gregs[32];
+  uint32_t flags;
+  uint32_t pading;
+  uint64_t extcontext[0] __attribute__((__aligned__(16)));
+};
+
+struct ContextTraits64 : public Traits64 {
+  using MContext = MContext64;
+  using SignalThreadContext = ThreadContext::t64_t;
+  using SignalFloatContext = FloatContext::f64_t;
+  using CPUContext = CPUContextLOONG64;
+};
+
+template <typename Traits>
+struct UContext {
+  typename Traits::ULong flags;
+  typename Traits::Address link;
+  SignalStack<Traits> stack;
+  Sigset<Traits> sigmask;
+  char padding[128 - sizeof(sigmask)];
+  uint64_t pading1;
+  typename Traits::MContext mcontext;
+};
+
+static_assert(offsetof(UContext<ContextTraits64>, mcontext) ==
+                  offsetof(ucontext_t, uc_mcontext),
+              "context offset mismtach");
+static_assert(offsetof(UContext<ContextTraits64>, mcontext.gregs) ==
+                  offsetof(ucontext_t, uc_mcontext.__gregs),
+              "context offset mismatch");
+static_assert(offsetof(UContext<ContextTraits64>, mcontext.extcontext) ==
+                  offsetof(ucontext_t, uc_mcontext.__extcontext),
+              "context offset mismatch");
 
 #else
 #error Port.
diff --git a/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
index 84871551018049798ee8a44d8eb2cceedfdb8336..8488fa697d9fd5eb7df3885ba6db021345b372b1 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
@@ -205,6 +205,8 @@ CPUArchitecture SystemSnapshotLinux::GetCPUArchitecture() const {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return process_reader_->Is64Bit() ? kCPUArchitectureMIPS64EL
                                     : kCPUArchitectureMIPSEL;
+#elif defined(ARCH_CPU_LOONG64)
+  return kCPUArchitectureLOONG64;
 #else
 #error port to your architecture
 #endif
@@ -220,6 +222,9 @@ uint32_t SystemSnapshotLinux::CPURevision() const {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return 0;
+#elif defined(ARCH_CPU_LOONG64)
+  // Not implementable on LOONG64
+  return 0;
 #else
 #error port to your architecture
 #endif
@@ -240,6 +245,9 @@ std::string SystemSnapshotLinux::CPUVendor() const {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return std::string();
+#elif defined(ARCH_CPU_LOONG64)
+  // Not implementable on LOONG64
+  return std::string();
 #else
 #error port to your architecture
 #endif
@@ -373,6 +381,9 @@ bool SystemSnapshotLinux::NXEnabled() const {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return false;
+#elif defined(ARCH_CPU_LOONG64)
+  // Not implementable on LOONG64
+  return false;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc b/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc
index 7d9d08d2ed4cecd8b08506e379f1b2952f346c02..45c309e47b4b0c667ec8c24be11b0e849d39927a 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc
@@ -110,6 +110,9 @@ bool WriteTestModule(const base::FilePath& module_path,
   module.ehdr.e_machine = EM_AARCH64;
 #elif defined(ARCH_CPU_MIPSEL) || defined(ARCH_CPU_MIPS64EL)
   module.ehdr.e_machine = EM_MIPS;
+#elif defined(ARCH_CPU_LOONG64)
+  module.ehdr.e_machine = EM_LOONGARCH;
+  module.ehdr.e_flags |= EF_LARCH_ABI_LP64;
 #endif
 
   module.ehdr.e_version = EV_CURRENT;
diff --git a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
index ba334010936b2a2e22b236d29204cf36cfeb3b64..6b5988002fcbfd09023a5cff2972fb969f3abd1f 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
@@ -190,6 +190,12 @@ bool ThreadSnapshotLinux::Initialize(
         thread.thread_info.float_context.f32,
         context_.mipsel);
   }
+#elif defined(ARCH_CPU_LOONG64)
+  context_.architecture = kCPUArchitectureLOONG64;
+  context_.loong64 = &context_union_.loong64;
+  InitializeCPUContextLOONG64(thread.thread_info.thread_context.t64,
+      thread.thread_info.float_context.f64,
+      context_.loong64);
 #else
 #error Port.
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
index bd03f58200c40313949fb68475c9859faf7399bf..c25d49a1742af1821d2c21abb13ce6934db3c373 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
@@ -74,6 +74,8 @@ class ThreadSnapshotLinux final : public ThreadSnapshot {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
     CPUContextMIPS mipsel;
     CPUContextMIPS64 mips64;
+#elif defined(ARCH_CPU_LOONG64)
+    CPUContextLOONG64 loong64;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc b/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc
index f2fa2ab37abe6766cae558f521f5920282016516..70883a5b149bf884979f34ae7be537237bed6f0d 100644
--- a/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc
+++ b/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc
@@ -266,6 +266,30 @@ bool MinidumpContextConverter::Initialize(
     context_.mips64->fir = src->fir;
 
     memcpy(&context_.mips64->fpregs, &src->fpregs, sizeof(src->fpregs));
+  } else if (context_.architecture ==
+             CPUArchitecture::kCPUArchitectureLOONG64) {
+    context_memory_.resize(sizeof(CPUContextLOONG64));
+    context_.loong64 =
+        reinterpret_cast<CPUContextLOONG64*>(context_memory_.data());
+    const MinidumpContextLOONG64* src =
+        reinterpret_cast<const MinidumpContextLOONG64*>(minidump_context.data());
+    if (minidump_context.size() < sizeof(MinidumpContextLOONG64)) {
+      return false;
+    }
+
+    if (!(src->context_flags & kMinidumpContextLOONG64)) {
+      return false;
+    }
+
+    for (size_t i = 0; i < std::size(src->regs); i++) {
+      context_.loong64->regs[i] = src->regs[i];
+    }
+
+    context_.loong64->csr_era = src->csr_era;
+    context_.loong64->fcsr = src->fcsr;
+    context_.loong64->fcc = src->fcc;
+
+    memcpy(&context_.loong64->fpregs, &src->fpregs, sizeof(src->fpregs));
   } else {
     // Architecture is listed as "unknown".
     DLOG(ERROR) << "Unknown architecture";
diff --git a/third_party/crashpad/crashpad/snapshot/minidump/system_snapshot_minidump.cc b/third_party/crashpad/crashpad/snapshot/minidump/system_snapshot_minidump.cc
index abccda31872d448f065a5e430fa106e57862e268..bc0027d0d47d969cd80fd79cec07d94948a31238 100644
--- a/third_party/crashpad/crashpad/snapshot/minidump/system_snapshot_minidump.cc
+++ b/third_party/crashpad/crashpad/snapshot/minidump/system_snapshot_minidump.cc
@@ -68,7 +68,8 @@ CPUArchitecture SystemSnapshotMinidump::GetCPUArchitecture() const {
     case kMinidumpCPUArchitectureMIPS:
       return kCPUArchitectureMIPSEL;
     // No word on how MIPS64 is signalled
-
+    case kMinidumpCPUArchitectureLOONG64:
+      return kCPUArchitectureLOONG64;
     default:
       return CPUArchitecture::kCPUArchitectureUnknown;
   }
diff --git a/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.cc b/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.cc
index 7efbf5af8666ab2b0362476b474d82e39b84b68c..bb66120985c41752eb3700d3c075c07e1ddf29b2 100644
--- a/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.cc
+++ b/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.cc
@@ -295,5 +295,30 @@ void InitializeCPUContextMIPS64(CPUContext* context, uint32_t seed) {
   mips64->dsp_control = value++;
 }
 
+void InitializeCPUContextLOONG64(CPUContext* context, uint32_t seed) {
+  context->architecture = kCPUArchitectureLOONG64;
+  CPUContextLOONG64* loong64 = context->loong64;
+
+  if (seed == 0) {
+    memset(loong64, 0, sizeof(*loong64));
+    return;
+  }
+
+  uint64_t value = seed;
+
+  for (size_t index = 0; index < std::size(loong64->regs); ++index) {
+    loong64->regs[index] = value++;
+  }
+
+  loong64->csr_era = value++;
+
+  for (size_t index = 0; index < std::size(loong64->fpregs.dregs); ++index) {
+    loong64->fpregs.dregs[index] = static_cast<double>(value++);
+  }
+
+  loong64->fcsr = value++;
+  loong64->fcc = value++;
+}
+
 }  // namespace test
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.h b/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.h
index e4372ceed8e6bc46aa5b6ade14d71852d0fe9214..8fb542296c840da60c92f2727091c6e87435c180 100644
--- a/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.h
+++ b/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.h
@@ -63,6 +63,7 @@ void InitializeCPUContextARM(CPUContext* context, uint32_t seed);
 void InitializeCPUContextARM64(CPUContext* context, uint32_t seed);
 void InitializeCPUContextMIPS(CPUContext* context, uint32_t seed);
 void InitializeCPUContextMIPS64(CPUContext* context, uint32_t seed);
+void InitializeCPUContextLOONG64(CPUContext* context, uint32_t seed);
 //! \}
 
 }  // namespace test
diff --git a/third_party/crashpad/crashpad/test/linux/get_tls.cc b/third_party/crashpad/crashpad/test/linux/get_tls.cc
index c8147f0dfb25756a486f8669ff54f680d6b5b6a4..4d37fd54b53cb630c8323b7ef2d53beffef425bd 100644
--- a/third_party/crashpad/crashpad/test/linux/get_tls.cc
+++ b/third_party/crashpad/crashpad/test/linux/get_tls.cc
@@ -49,6 +49,9 @@ LinuxVMAddress GetTLS() {
       : "=r"(tls)
       :
       : "$3");
+#elif defined(ARCH_CPU_LOONG64)
+  asm("move    %0,$tp\n\t"
+      : "=r"(tls) ::);
 #else
 #error Port.
 #endif  // ARCH_CPU_ARMEL
diff --git a/third_party/crashpad/crashpad/test/multiprocess_posix.cc b/third_party/crashpad/crashpad/test/multiprocess_posix.cc
index eb7cf9cd15c56087f76cb3b89b890c98a760f0d9..9b7a610b06d1ac5e30c70c6abd4395c9957ab1bc 100644
--- a/third_party/crashpad/crashpad/test/multiprocess_posix.cc
+++ b/third_party/crashpad/crashpad/test/multiprocess_posix.cc
@@ -162,7 +162,8 @@ void Multiprocess::SetExpectedChildTermination(TerminationReason reason,
 }
 
 void Multiprocess::SetExpectedChildTerminationBuiltinTrap() {
-#if defined(ARCH_CPU_ARM64) || defined(ARCH_CPU_MIPS_FAMILY)
+#if defined(ARCH_CPU_ARM64) || defined(ARCH_CPU_MIPS_FAMILY) ||\
+    defined (ARCH_CPU_LOONG64)
   SetExpectedChildTermination(kTerminationSignal, SIGTRAP);
 #else
   SetExpectedChildTermination(kTerminationSignal, SIGILL);
diff --git a/third_party/crashpad/crashpad/util/linux/exception_handler_client.cc b/third_party/crashpad/crashpad/util/linux/exception_handler_client.cc
index cef493df70f643184a5f9781a6366d89bdc77a67..12a2ae9fa5cba4134327783549fa1e938aca24b6 100644
--- a/third_party/crashpad/crashpad/util/linux/exception_handler_client.cc
+++ b/third_party/crashpad/crashpad/util/linux/exception_handler_client.cc
@@ -40,9 +40,9 @@ namespace {
 
 class ScopedSigprocmaskRestore {
  public:
-  explicit ScopedSigprocmaskRestore(const kernel_sigset_t& set_to_block)
+  explicit ScopedSigprocmaskRestore(const sigset_t& set_to_block)
       : orig_mask_(), mask_is_set_(false) {
-    mask_is_set_ = sys_sigprocmask(SIG_BLOCK, &set_to_block, &orig_mask_) == 0;
+    mask_is_set_ = sigprocmask(SIG_BLOCK, &set_to_block, &orig_mask_) == 0;
     DPLOG_IF(ERROR, !mask_is_set_) << "sigprocmask";
   }
 
@@ -51,13 +51,13 @@ class ScopedSigprocmaskRestore {
 
   ~ScopedSigprocmaskRestore() {
     if (mask_is_set_ &&
-        sys_sigprocmask(SIG_SETMASK, &orig_mask_, nullptr) != 0) {
+        sigprocmask(SIG_SETMASK, &orig_mask_, nullptr) != 0) {
       DPLOG(ERROR) << "sigprocmask";
     }
   }
 
  private:
-  kernel_sigset_t orig_mask_;
+  sigset_t orig_mask_;
   bool mask_is_set_;
 };
 
@@ -122,9 +122,9 @@ void ExceptionHandlerClient::SetCanSetPtracer(bool can_set_ptracer) {
 int ExceptionHandlerClient::SignalCrashDump(
     const ExceptionHandlerProtocol::ClientInformation& info,
     VMAddress stack_pointer) {
-  kernel_sigset_t dump_done_sigset;
-  sys_sigemptyset(&dump_done_sigset);
-  sys_sigaddset(&dump_done_sigset, ExceptionHandlerProtocol::kDumpDoneSignal);
+  sigset_t dump_done_sigset;
+  sigemptyset(&dump_done_sigset);
+  sigaddset(&dump_done_sigset, ExceptionHandlerProtocol::kDumpDoneSignal);
   ScopedSigprocmaskRestore scoped_block(dump_done_sigset);
 
   int status = SendCrashDumpRequest(info, stack_pointer);
@@ -136,7 +136,7 @@ int ExceptionHandlerClient::SignalCrashDump(
   timespec timeout;
   timeout.tv_sec = 5;
   timeout.tv_nsec = 0;
-  if (HANDLE_EINTR(sys_sigtimedwait(&dump_done_sigset, &siginfo, &timeout)) <
+  if (HANDLE_EINTR(sigtimedwait(&dump_done_sigset, &siginfo, &timeout)) <
       0) {
     return errno;
   }
diff --git a/third_party/crashpad/crashpad/util/linux/ptracer.cc b/third_party/crashpad/crashpad/util/linux/ptracer.cc
index 25c89ea95c64584023983888de2479597790e478..9bd9735bbec30a684306cefce4b4ca7c6473a897 100644
--- a/third_party/crashpad/crashpad/util/linux/ptracer.cc
+++ b/third_party/crashpad/crashpad/util/linux/ptracer.cc
@@ -398,6 +398,60 @@ bool GetThreadArea64(pid_t tid,
   return true;
 }
 
+#elif defined(ARCH_CPU_LOONG64)
+
+#include <asm/ptrace.h>
+
+bool GetFloatingPointRegisters32(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) {
+  return false;
+}
+
+bool GetFloatingPointRegisters64(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) {
+  iovec iov;
+  iov.iov_base = context;
+  iov.iov_len = sizeof(*context);
+  if (ptrace(PTRACE_GETREGSET, tid, reinterpret_cast<void*>(NT_PRFPREG), &iov) != 0) {
+    PLOG_IF(ERROR, can_log) << "ptrace";
+    return false;
+  }
+  if (iov.iov_len != sizeof(context->f64)) {
+    LOG_IF(ERROR, can_log) << "Unexpected registers size " << iov.iov_len
+                           << " != " << sizeof(context->f64);
+    return false;
+  }
+
+  return true;
+}
+
+bool GetThreadArea32(pid_t tid,
+                     const ThreadContext& context,
+                     LinuxVMAddress* address,
+                     bool can_log) {
+  return false;
+}
+
+bool GetThreadArea64(pid_t tid,
+                     const ThreadContext& context,
+                     LinuxVMAddress* address,
+                     bool can_log) {
+  struct user_pt_regs loongarch_regs;
+  struct iovec iov = {
+     .iov_base = &loongarch_regs,
+     .iov_len = sizeof(loongarch_regs)
+  };
+
+  if (ptrace(PTRACE_GETREGSET, tid, NT_PRSTATUS, &iov) != 0) {
+    PLOG_IF(ERROR, can_log) << "ptrace";
+    return false;
+  }
+  *address = loongarch_regs.regs[2];
+  return true;
+}
+
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/util/linux/thread_info.h b/third_party/crashpad/crashpad/util/linux/thread_info.h
index 9f60bd3ebe3118514d6727a8a356aa5e12234973..11fb19e9a72c812ec6a94137df19c293b7d9848a 100644
--- a/third_party/crashpad/crashpad/util/linux/thread_info.h
+++ b/third_party/crashpad/crashpad/util/linux/thread_info.h
@@ -80,6 +80,8 @@ union ThreadContext {
     uint32_t cp0_status;
     uint32_t cp0_cause;
     uint32_t padding1_;
+#elif defined(ARCH_CPU_LOONG64)
+    // Nothing.
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -133,6 +135,13 @@ union ThreadContext {
     uint64_t cp0_badvaddr;
     uint64_t cp0_status;
     uint64_t cp0_cause;
+#elif defined(ARCH_CPU_LOONG64)
+    // Reflects user_regs_struct in sys/user.h.
+    uint64_t regs[32];
+    uint64_t orig_a0;
+    uint64_t csr_era;
+    uint64_t csr_badv;
+    uint64_t reserved[10];
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -142,13 +151,13 @@ union ThreadContext {
   using NativeThreadContext = user_regs_struct;
 #elif defined(ARCH_CPU_ARMEL)
   using NativeThreadContext = user_regs;
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined (ARCH_CPU_LOONG64)
 // No appropriate NativeThreadsContext type available for MIPS
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY || ARCH_CPU_ARM64
 
-#if !defined(ARCH_CPU_MIPS_FAMILY)
+#if !defined(ARCH_CPU_MIPS_FAMILY) && !defined(ARCH_CPU_LOONG64)
 #if defined(ARCH_CPU_32_BITS)
   static_assert(sizeof(t32_t) == sizeof(NativeThreadContext), "Size mismatch");
 #else  // ARCH_CPU_64_BITS
@@ -219,6 +228,8 @@ union FloatContext {
     } fpregs[32];
     uint32_t fpcsr;
     uint32_t fpu_id;
+#elif defined(ARCH_CPU_LOONG64)
+    // Nothing.
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -253,6 +264,11 @@ union FloatContext {
     double fpregs[32];
     uint32_t fpcsr;
     uint32_t fpu_id;
+#elif defined(ARCH_CPU_LOONG64)
+    double fpregs[32];
+    uint64_t fcc;
+    uint32_t fcsr;
+    uint32_t _pad;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -280,7 +296,7 @@ union FloatContext {
 #endif
 #elif defined(ARCH_CPU_ARM64)
   static_assert(sizeof(f64) == sizeof(user_fpsimd_struct), "Size mismatch");
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined (ARCH_CPU_LOONG64)
 // No appropriate floating point context native type for available MIPS.
 #else
 #error Port.
diff --git a/third_party/crashpad/crashpad/util/misc/capture_context.h b/third_party/crashpad/crashpad/util/misc/capture_context.h
index a5503d682f82e16ca4df4e522b733c6f428e0c7f..172930b3bf9ed49fddaecb7fa49ccc2ea8d613e9 100644
--- a/third_party/crashpad/crashpad/util/misc/capture_context.h
+++ b/third_party/crashpad/crashpad/util/misc/capture_context.h
@@ -23,6 +23,9 @@
 #include <windows.h>
 #elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_ANDROID)
 #include <ucontext.h>
+#if defined(ARCH_CPU_LOONG64)
+#include <asm/sigcontext.h>
+#endif
 #elif BUILDFLAG(IS_FUCHSIA)
 #include <signal.h>
 #endif  // BUILDFLAG(IS_APPLE)
@@ -39,7 +42,14 @@ using NativeCPUContext = arm_unified_thread_state;
 using NativeCPUContext = CONTEXT;
 #elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || \
     BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_FUCHSIA)
+#if defined(ARCH_CPU_LOONG64)
+typedef struct {
+  ucontext_t ucontext;
+  struct sctx_info contextinfo;
+}NativeCPUContext;
+#else
 using NativeCPUContext = ucontext_t;
+#endif
 #endif  // BUILDFLAG(IS_APPLE)
 
 //! \brief Saves the CPU context.
@@ -69,6 +79,7 @@ using NativeCPUContext = ucontext_t;
 //!     macOS/Linux/Fuchsia | x86_64       | `%%rdi`
 //!     Linux               | ARM/ARM64    | `r0`/`x0`
 //!     Linux               | MIPS/MIPS64  | `$a0`
+//!     Linux               | LOONG64      | `$a0`
 //!
 //!     Additionally, the value `LR` on ARM/ARM64 will be the return address of
 //!     this function.
diff --git a/third_party/crashpad/crashpad/util/misc/capture_context_linux.S b/third_party/crashpad/crashpad/util/misc/capture_context_linux.S
index 9c3a72638151aa3f355c82a1a2e2afd005eb218c..cca55b70c87924d41c4be29bb6966bf9c70c62f0 100644
--- a/third_party/crashpad/crashpad/util/misc/capture_context_linux.S
+++ b/third_party/crashpad/crashpad/util/misc/capture_context_linux.S
@@ -24,22 +24,26 @@
 // compatibility with both possibilities.
 #define CAPTURECONTEXT_SYMBOL _ZN8crashpad14CaptureContextEP10ucontext_t
 #define CAPTURECONTEXT_SYMBOL2 _ZN8crashpad14CaptureContextEP8ucontext
+#define CAPTURECONTEXT_SYMBOL3 _ZN8crashpad14CaptureContextEPNS_16NativeCPUContextE
 
   .text
   .globl CAPTURECONTEXT_SYMBOL
   .globl CAPTURECONTEXT_SYMBOL2
+  .globl CAPTURECONTEXT_SYMBOL3
 #if defined(__i386__) || defined(__x86_64__)
   .balign 16, 0x90
-#elif defined(__arm__) || defined(__aarch64__)
+#elif defined(__arm__) || defined(__aarch64__) || defined(__loongarch_lp64)
   .balign 4, 0x0
   .type CAPTURECONTEXT_SYMBOL, %function
   .type CAPTURECONTEXT_SYMBOL2, %function
+  .type CAPTURECONTEXT_SYMBOL3, %function
 #elif defined(__mips__)
   .balign 4, 0x0
 #endif
 
 CAPTURECONTEXT_SYMBOL:
 CAPTURECONTEXT_SYMBOL2:
+CAPTURECONTEXT_SYMBOL3:
   CRASHPAD_AARCH64_VALID_CALL_TARGET
 
 #if defined(__i386__)
@@ -427,4 +431,48 @@ CAPTURECONTEXT_SYMBOL2:
   jr $ra
 
   .set at
+#elif defined(__loongarch_lp64)
+
+#define MCONTEXT_GREG_SIZE 8
+#define MCONTEXT_PC_OFFSET 176
+#define MCONTEXT_GREGS_OFFSET 184
+
+#define STORE_GPR(X) st.d $r##X, $a0, MCONTEXT_GREGS_OFFSET + X * MCONTEXT_GREG_SIZE
+#define STORE_PC st.d $ra, $a0, MCONTEXT_PC_OFFSET
+
+  STORE_PC
+  STORE_GPR(0)
+  STORE_GPR(1)
+  STORE_GPR(2)
+  STORE_GPR(3)
+  STORE_GPR(4)
+  STORE_GPR(5)
+  STORE_GPR(6)
+  STORE_GPR(7)
+  STORE_GPR(8)
+  STORE_GPR(9)
+  STORE_GPR(10)
+  STORE_GPR(11)
+  STORE_GPR(12)
+  STORE_GPR(13)
+  STORE_GPR(14)
+  STORE_GPR(15)
+  STORE_GPR(16)
+  STORE_GPR(17)
+  STORE_GPR(18)
+  STORE_GPR(19)
+  STORE_GPR(20)
+  STORE_GPR(21)
+  STORE_GPR(22)
+  STORE_GPR(23)
+  STORE_GPR(24)
+  STORE_GPR(25)
+  STORE_GPR(26)
+  STORE_GPR(27)
+  STORE_GPR(28)
+  STORE_GPR(29)
+  STORE_GPR(30)
+  STORE_GPR(31)
+
+  jirl $zero, $ra, 0
 #endif  // __i386__
diff --git a/third_party/crashpad/crashpad/util/misc/capture_context_test.cc b/third_party/crashpad/crashpad/util/misc/capture_context_test.cc
index f353aebe66b3062258a9187fe402b2a7b5e931a0..ce45cb4887a74a8f0242e4ba78fdeab4e875f47c 100644
--- a/third_party/crashpad/crashpad/util/misc/capture_context_test.cc
+++ b/third_party/crashpad/crashpad/util/misc/capture_context_test.cc
@@ -57,7 +57,7 @@ void TestCaptureContext() {
   uintptr_t pc = ProgramCounterFromContext(context_1);
 
 #if !defined(ADDRESS_SANITIZER) && !defined(ARCH_CPU_MIPS_FAMILY) && \
-    !defined(MEMORY_SANITIZER)
+    !defined(MEMORY_SANITIZER) && !defined(ARCH_CPU_LOONG64)
   // Sanitizers can cause enough code bloat that the â€œnearbyâ€ check would
   // likely fail.
   const uintptr_t kReferencePC =
diff --git a/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc b/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc
index 35751bf8b21db96a20403c092fdd890925f572d2..b3811b5abfb5ee94893f10e51b7e64ada61a10a8 100644
--- a/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc
+++ b/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc
@@ -35,6 +35,8 @@ void SanityCheckContext(const NativeCPUContext& context) {
   EXPECT_EQ(context.uc_mcontext.regs[0], FromPointerCast<uintptr_t>(&context));
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   EXPECT_EQ(context.uc_mcontext.gregs[4], FromPointerCast<uintptr_t>(&context));
+#elif defined(ARCH_CPU_LOONG64)
+  EXPECT_EQ(context.ucontext.uc_mcontext.__gregs[4], FromPointerCast<uintptr_t>(&context));
 #endif
 }
 
@@ -49,6 +51,8 @@ uintptr_t ProgramCounterFromContext(const NativeCPUContext& context) {
   return context.uc_mcontext.pc;
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return context.uc_mcontext.pc;
+#elif defined(ARCH_CPU_LOONG64)
+  return context.ucontext.uc_mcontext.__pc;
 #endif
 }
 
@@ -63,6 +67,8 @@ uintptr_t StackPointerFromContext(const NativeCPUContext& context) {
   return context.uc_mcontext.sp;
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return context.uc_mcontext.gregs[29];
+#elif defined(ARCH_CPU_LOONG64)
+  return context.ucontext.uc_mcontext.__gregs[3];
 #endif
 }
 
diff --git a/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc b/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
index d5c9177f952a5c963a131a702af07e1c83e06e0a..b6906707b511f13916b72ad9aa27cb936dfdcc80 100644
--- a/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
+++ b/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
@@ -237,6 +237,8 @@ std::string UserAgent() {
 #elif defined(ARCH_CPU_BIG_ENDIAN)
     static constexpr char arch[] = "aarch64_be";
 #endif
+#elif defined(ARCH_CPU_LOONG64)
+    static constexpr char arch[] = "loong64";
 #else
 #error Port
 #endif
